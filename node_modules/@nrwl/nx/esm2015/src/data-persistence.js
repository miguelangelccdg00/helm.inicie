/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
import { Injectable } from '@angular/core';
import { Actions, ofType } from '@ngrx/effects';
import { ROUTER_NAVIGATION } from '@ngrx/router-store';
import { Store } from '@ngrx/store';
import { Observable, of } from 'rxjs';
import { catchError, concatMap, filter, groupBy, map, mergeMap, switchMap, withLatestFrom } from 'rxjs/operators';
/**
 * See {\@link DataPersistence.pessimisticUpdate} for more information.
 * @record
 * @template T, A
 */
export function PessimisticUpdateOpts() { }
if (false) {
    /**
     * @param {?} a
     * @param {?=} state
     * @return {?}
     */
    PessimisticUpdateOpts.prototype.run = function (a, state) { };
    /**
     * @param {?} a
     * @param {?} e
     * @return {?}
     */
    PessimisticUpdateOpts.prototype.onError = function (a, e) { };
}
/**
 * See {\@link DataPersistence.pessimisticUpdate} for more information.
 * @record
 * @template T, A
 */
export function OptimisticUpdateOpts() { }
if (false) {
    /**
     * @param {?} a
     * @param {?=} state
     * @return {?}
     */
    OptimisticUpdateOpts.prototype.run = function (a, state) { };
    /**
     * @param {?} a
     * @param {?} e
     * @return {?}
     */
    OptimisticUpdateOpts.prototype.undoAction = function (a, e) { };
}
/**
 * See {\@link DataPersistence.fetch} for more information.
 * @record
 * @template T, A
 */
export function FetchOpts() { }
if (false) {
    /**
     * @param {?} a
     * @param {?=} state
     * @return {?}
     */
    FetchOpts.prototype.id = function (a, state) { };
    /**
     * @param {?} a
     * @param {?=} state
     * @return {?}
     */
    FetchOpts.prototype.run = function (a, state) { };
    /**
     * @param {?} a
     * @param {?} e
     * @return {?}
     */
    FetchOpts.prototype.onError = function (a, e) { };
}
/**
 * See {\@link DataPersistence.navigation} for more information.
 * @record
 * @template T
 */
export function HandleNavigationOpts() { }
if (false) {
    /**
     * @param {?} a
     * @param {?=} state
     * @return {?}
     */
    HandleNavigationOpts.prototype.run = function (a, state) { };
    /**
     * @param {?} a
     * @param {?} e
     * @return {?}
     */
    HandleNavigationOpts.prototype.onError = function (a, e) { };
}
/**
 * @template T, A
 * @param {?} opts
 * @return {?}
 */
export function pessimisticUpdate(opts) {
    return (source) => {
        return source.pipe(mapActionAndState(), concatMap(runWithErrorHandling(opts.run, opts.onError)));
    };
}
/**
 * @template T, A
 * @param {?} opts
 * @return {?}
 */
export function optimisticUpdate(opts) {
    return (source) => {
        return source.pipe(mapActionAndState(), concatMap(runWithErrorHandling(opts.run, opts.undoAction)));
    };
}
/**
 * @template T, A
 * @param {?} opts
 * @return {?}
 */
export function fetch(opts) {
    return (source) => {
        if (opts.id) {
            /** @type {?} */
            const groupedFetches = source.pipe(mapActionAndState(), groupBy(([action, store]) => {
                return opts.id(action, store);
            }));
            return groupedFetches.pipe(mergeMap(pairs => pairs.pipe(switchMap(runWithErrorHandling(opts.run, opts.onError)))));
        }
        return source.pipe(mapActionAndState(), concatMap(runWithErrorHandling(opts.run, opts.onError)));
    };
}
/**
 * @template T, A
 * @param {?} component
 * @param {?} opts
 * @return {?}
 */
export function navigation(component, opts) {
    return (source) => {
        /** @type {?} */
        const nav = source.pipe(mapActionAndState(), filter(([action, state]) => isStateSnapshot(action)), map(([action, state]) => {
            if (!isStateSnapshot(action)) {
                // Because of the above filter we'll never get here,
                // but this properly type narrows `action`
                return;
            }
            return (/** @type {?} */ ([
                findSnapshot(component, action.payload.routerState.root),
                state
            ]));
        }), filter(([snapshot, state]) => !!snapshot));
        return nav.pipe(switchMap(runWithErrorHandling(opts.run, opts.onError)));
    };
}
/**
 * @param {?} action
 * @return {?}
 */
function isStateSnapshot(action) {
    return action.type === ROUTER_NAVIGATION;
}
/**
 * @template T, A, R
 * @param {?} run
 * @param {?} onError
 * @return {?}
 */
function runWithErrorHandling(run, onError) {
    return ([action, state]) => {
        try {
            /** @type {?} */
            const r = wrapIntoObservable(run(action, state));
            return r.pipe(catchError(e => wrapIntoObservable(onError(action, e))));
        }
        catch (e) {
            return wrapIntoObservable(onError(action, e));
        }
    };
}
/**
 * \@whatItDoes maps Observable<Action | [Action, State]> to
 * Observable<[Action, State]>
 * @template T, A
 * @return {?}
 */
function mapActionAndState() {
    return (source) => {
        return source.pipe(map(value => {
            const [action, store] = normalizeActionAndState(value);
            return (/** @type {?} */ ([action, store]));
        }));
    };
}
/**
 * \@whatItDoes Normalizes either a bare action or an array of action and state
 * into an array of action and state (or undefined)
 * @template T, A
 * @param {?} args
 * @return {?}
 */
function normalizeActionAndState(args) {
    /** @type {?} */
    let action;
    /** @type {?} */
    let state;
    if (args instanceof Array) {
        [action, state] = args;
    }
    else {
        action = args;
    }
    return [action, state];
}
/**
 * \@whatItDoes Provides convenience methods for implementing common operations of persisting data.
 * @template T
 */
export class DataPersistence {
    /**
     * @param {?} store
     * @param {?} actions
     */
    constructor(store, actions) {
        this.store = store;
        this.actions = actions;
    }
    /**
     *
     * \@whatItDoes Handles pessimistic updates (updating the server first).
     *
     * Update the server implemented naively suffers from race conditions and poor error handling.
     *
     * `pessimisticUpdate` addresses these problems--it runs all fetches in order, which removes race conditions
     * and forces the developer to handle errors.
     *
     * ## Example:
     *
     * ```typescript
     * \@Injectable()
     * class TodoEffects {
     * \@Effect() updateTodo = this.s.pessimisticUpdate<UpdateTodo>('UPDATE_TODO', {
     *     // provides an action and the current state of the store
     *     run(a, state) {
     *       // update the backend first, and then dispatch an action that will
     *       // update the client side
     *       return this.backend(state.user, a.payload).map(updated => ({
     *         type: 'TODO_UPDATED',
     *         payload: updated
     *       }));
     *     },
     *
     *     onError(a, e: any) {
     *       // we don't need to undo the changes on the client side.
     *       // we can dispatch an error, or simply log the error here and return `null`
     *       return null;
     *     }
     *   });
     *
     *   constructor(private s: DataPersistence<TodosState>, private backend: Backend) {}
     * }
     * ```
     *
     * Note that if you don't return a new action from the run callback, you must set the dispatch property
     * of the effect to false, like this:
     *
     * ```
     * class TodoEffects {
     * \@Effect({dispatch: false})
     *   updateTodo; //...
     * }
     * ```
     * @template A
     * @param {?} actionType
     * @param {?} opts
     * @return {?}
     */
    pessimisticUpdate(actionType, opts) {
        return this.actions.pipe(ofType(actionType), withLatestFrom(this.store), pessimisticUpdate(opts));
    }
    /**
     *
     * \@whatItDoes Handles optimistic updates (updating the client first).
     *
     * `optimisticUpdate` addresses these problems--it runs all fetches in order, which removes race conditions
     * and forces the developer to handle errors.
     *
     * `optimisticUpdate` is different from `pessimisticUpdate`. In case of a failure, when using `optimisticUpdate`,
     * the developer already updated the state locally, so the developer must provide an undo action.
     *
     * The error handling must be done in the callback, or by means of the undo action.
     *
     * ## Example:
     *
     * ```typescript
     * \@Injectable()
     * class TodoEffects {
     * \@Effect() updateTodo = this.s.optimisticUpdate<UpdateTodo>('UPDATE_TODO', {
     *     // provides an action and the current state of the store
     *     run: (a, state) => {
     *       return this.backend(state.user, a.payload);
     *     },
     *
     *     undoAction: (a, e: any) => {
     *       // dispatch an undo action to undo the changes in the client state
     *       return ({
     *         type: 'UNDO_UPDATE_TODO',
     *         payload: a
     *       });
     *     }
     *   });
     *
     *   constructor(private s: DataPersistence<TodosState>, private backend: Backend) {}
     * }
     * ```
     *
     * Note that if you don't return a new action from the run callback, you must set the dispatch property
     * of the effect to false, like this:
     *
     * ```
     * class TodoEffects {
     * \@Effect({dispatch: false})
     *   updateTodo; //...
     * }
     * ```
     * @template A
     * @param {?} actionType
     * @param {?} opts
     * @return {?}
     */
    optimisticUpdate(actionType, opts) {
        return this.actions.pipe(ofType(actionType), withLatestFrom(this.store), optimisticUpdate(opts));
    }
    /**
     *
     * \@whatItDoes Handles data fetching.
     *
     * Data fetching implemented naively suffers from race conditions and poor error handling.
     *
     * `fetch` addresses these problems--it runs all fetches in order, which removes race conditions
     * and forces the developer to handle errors.
     *
     * ## Example:
     *
     * ```typescript
     * \@Injectable()
     * class TodoEffects {
     * \@Effect() loadTodos = this.s.fetch<GetTodos>('GET_TODOS', {
     *     // provides an action and the current state of the store
     *     run: (a, state) => {
     *       return this.backend(state.user, a.payload).map(r => ({
     *         type: 'TODOS',
     *         payload: r
     *       });
     *     },
     *
     *     onError: (a, e: any) => {
     *       // dispatch an undo action to undo the changes in the client state
     *     }
     *   });
     *
     *   constructor(private s: DataPersistence<TodosState>, private backend: Backend) {}
     * }
     * ```
     *
     * This is correct, but because it set the concurrency to 1, it may not be performant.
     *
     * To fix that, you can provide the `id` function, like this:
     *
     * ```typescript / loadTodo = this.s.fetch<GetTodo>('GET_TODO', {
     *     id: (a, state) => {
     *       return a.payload.id;
     *     }
     *
     *     // provides an action and the current state of the store
     *     run: (a, state) => {
     *       return this.backend(state.user, a.payload).map(r => ({
     *         type: 'TODO',
     *         payload: r
     *       });
     *     },
     *
     *     onError: (a, e: any) => {
     *       // dispatch an undo action to undo the changes in the client state
     *       return null;
     *     }
     *   });
     *
     *   constructor(private s: DataPersistence<TodosState>, private backend: Backend) {}
     * }
     * ```
     *
     * With this setup, the requests for Todo 1 will run concurrently with the requests for Todo 2.
     *
     * In addition, if DataPersistence notices that there are multiple requests for Todo 1 scheduled,
     * it will only run the last one.
     * @template A
     * @param {?} actionType
     * @param {?} opts
     * @return {?}
     */
    fetch(actionType, opts) {
        return this.actions.pipe(ofType(actionType), withLatestFrom(this.store), fetch(opts));
    }
    /**
     * \@whatItDoes Handles data fetching as part of router navigation.
     *
     * Data fetching implemented naively suffers from race conditions and poor error handling.
     *
     * `navigation` addresses these problems.
     *
     * It checks if an activated router state contains the passed in component type, and, if it does, runs the `run`
     * callback. It provides the activated snapshot associated with the component and the current state. And it only runs
     * the last request.
     *
     * ## Example:
     *
     * ```typescript
     * \@Injectable()
     * class TodoEffects {
     * \@Effect() loadTodo = this.s.navigation(TodoComponent, {
     *     run: (a, state) => {
     *       return this.backend.fetchTodo(a.params['id']).map(todo => ({
     *         type: 'TODO_LOADED',
     *         payload: todo
     *       }));
     *     },
     *     onError: (a, e: any) => {
     *       // we can log and error here and return null
     *       // we can also navigate back
     *       return null;
     *     }
     *   });
     *   constructor(private s: DataPersistence<TodosState>, private backend: Backend) {}
     * }
     * ```
     * @param {?} component
     * @param {?} opts
     * @return {?}
     */
    navigation(component, opts) {
        return this.actions.pipe(withLatestFrom(this.store), navigation(component, opts));
    }
}
DataPersistence.decorators = [
    { type: Injectable }
];
/** @nocollapse */
DataPersistence.ctorParameters = () => [
    { type: Store },
    { type: Actions }
];
if (false) {
    /** @type {?} */
    DataPersistence.prototype.store;
    /** @type {?} */
    DataPersistence.prototype.actions;
}
/**
 * @param {?} component
 * @param {?} s
 * @return {?}
 */
function findSnapshot(component, s) {
    if (s.routeConfig && s.routeConfig.component === component) {
        return s;
    }
    for (const c of s.children) {
        /** @type {?} */
        const ss = findSnapshot(component, c);
        if (ss) {
            return ss;
        }
    }
    return null;
}
/**
 * @template O
 * @param {?} obj
 * @return {?}
 */
function wrapIntoObservable(obj) {
    if (!!obj && obj instanceof Observable) {
        return obj;
    }
    else if (!obj) {
        return of();
    }
    else {
        return of((/** @type {?} */ (obj)));
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0YS1wZXJzaXN0ZW5jZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BucndsL254LyIsInNvdXJjZXMiOlsic3JjL2RhdGEtcGVyc2lzdGVuY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE9BQU8sRUFBRSxVQUFVLEVBQVEsTUFBTSxlQUFlLENBQUM7QUFFakQsT0FBTyxFQUFFLE9BQU8sRUFBRSxNQUFNLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDaEQsT0FBTyxFQUFFLGlCQUFpQixFQUEwQixNQUFNLG9CQUFvQixDQUFDO0FBQy9FLE9BQU8sRUFBVSxLQUFLLEVBQUUsTUFBTSxhQUFhLENBQUM7QUFDNUMsT0FBTyxFQUFFLFVBQVUsRUFBRSxFQUFFLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDdEMsT0FBTyxFQUNMLFVBQVUsRUFDVixTQUFTLEVBQ1QsTUFBTSxFQUNOLE9BQU8sRUFDUCxHQUFHLEVBQ0gsUUFBUSxFQUNSLFNBQVMsRUFDVCxjQUFjLEVBQ2YsTUFBTSxnQkFBZ0IsQ0FBQzs7Ozs7O0FBS3hCLDJDQUdDOzs7Ozs7O0lBRkMsOERBQXlEOzs7Ozs7SUFDekQsOERBQTZDOzs7Ozs7O0FBSy9DLDBDQUdDOzs7Ozs7O0lBRkMsNkRBQXlEOzs7Ozs7SUFDekQsZ0VBQXNEOzs7Ozs7O0FBTXhELCtCQUlDOzs7Ozs7O0lBSEMsaURBQTBCOzs7Ozs7SUFDMUIsa0RBQXlEOzs7Ozs7SUFDekQsa0RBQThDOzs7Ozs7O0FBTWhELDBDQUdDOzs7Ozs7O0lBRkMsNkRBQThFOzs7Ozs7SUFDOUUsNkRBQW1FOzs7Ozs7O0FBTXJFLE1BQU0sVUFBVSxpQkFBaUIsQ0FDL0IsSUFBaUM7SUFFakMsT0FBTyxDQUFDLE1BQStCLEVBQXNCLEVBQUU7UUFDN0QsT0FBTyxNQUFNLENBQUMsSUFBSSxDQUNoQixpQkFBaUIsRUFBRSxFQUNuQixTQUFTLENBQUMsb0JBQW9CLENBQUMsSUFBSSxDQUFDLEdBQUcsRUFBRSxJQUFJLENBQUMsT0FBTyxDQUFDLENB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SixDQUFDOzs7WUE3T0YsVUFBVTs7OztZQWpMTSxLQUFLO1lBRmIsT0FBTzs7OztJQXFMRixnQ0FBc0I7O0lBQUUsa0NBQXVCOzs7Ozs7O0FBOE83RCxTQUFTLFlBQVksQ0FDbkIsU0FBb0IsRUFDcEIsQ0FBeUI7SUFFekIsSUFBSSxDQUFDLENBQUMsV0FBVyxJQUFJLENBQUMsQ0FBQyxXQUFXLENBQUMsU0FBUyxLQUFLLFNBQVMsRUFBRTtRQUMxRCxPQUFPLENBQUMsQ0FBQztLQUNWO0lBQ0QsS0FBSyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsUUFBUSxFQUFFOztjQUNwQixFQUFFLEdBQUcsWUFBWSxDQUFDLFNBQVMsRUFBRSxDQUFDLENBQUM7UUFDckMsSUFBSSxFQUFFLEVBQUU7WUFDTixPQUFPLEVBQUUsQ0FBQztTQUNYO0tBQ0Y7SUFDRCxPQUFPLElBQUksQ0FBQztBQUNkLENBQUM7Ozs7OztBQUVELFNBQVMsa0JBQWtCLENBQUksR0FBNkI7SUFDMUQsSUFBSSxDQUFDLENBQUMsR0FBRyxJQUFJLEdBQUcsWUFBWSxVQUFVLEVBQUU7UUFDdEMsT0FBTyxHQUFHLENBQUM7S0FDWjtTQUFNLElBQUksQ0FBQyxHQUFHLEVBQUU7UUFDZixPQUFPLEVBQUUsRUFBRSxDQUFDO0tBQ2I7U0FBTTtRQUNMLE9BQU8sRUFBRSxDQUFDLG1CQUFBLEdBQUcsRUFBSyxDQUFDLENBQUM7S0FDckI7QUFDSCxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5qZWN0YWJsZSwgVHlwZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQWN0aXZhdGVkUm91dGVTbmFwc2hvdCwgUm91dGVyU3RhdGVTbmFwc2hvdCB9IGZyb20gJ0Bhbmd1bGFyL3JvdXRlcic7XG5pbXBvcnQgeyBBY3Rpb25zLCBvZlR5cGUgfSBmcm9tICdAbmdyeC9lZmZlY3RzJztcbmltcG9ydCB7IFJPVVRFUl9OQVZJR0FUSU9OLCBSb3V0ZXJOYXZpZ2F0aW9uQWN0aW9uIH0gZnJvbSAnQG5ncngvcm91dGVyLXN0b3JlJztcbmltcG9ydCB7IEFjdGlvbiwgU3RvcmUgfSBmcm9tICdAbmdyeC9zdG9yZSc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlLCBvZiB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHtcbiAgY2F0Y2hFcnJvcixcbiAgY29uY2F0TWFwLFxuICBmaWx0ZXIsXG4gIGdyb3VwQnksXG4gIG1hcCxcbiAgbWVyZ2VNYXAsXG4gIHN3aXRjaE1hcCxcbiAgd2l0aExhdGVzdEZyb21cbn0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuXG4vKipcbiAqIFNlZSB7QGxpbmsgRGF0YVBlcnNpc3RlbmNlLnBlc3NpbWlzdGljVXBkYXRlfSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBQZXNzaW1pc3RpY1VwZGF0ZU9wdHM8VCwgQT4ge1xuICBydW4oYTogQSwgc3RhdGU/OiBUKTogT2JzZXJ2YWJsZTxBY3Rpb24+IHwgQWN0aW9uIHwgdm9pZDtcbiAgb25FcnJvcihhOiBBLCBlOiBhbnkpOiBPYnNlcnZhYmxlPGFueT4gfCBhbnk7XG59XG4vKipcbiAqIFNlZSB7QGxpbmsgRGF0YVBlcnNpc3RlbmNlLnBlc3NpbWlzdGljVXBkYXRlfSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBPcHRpbWlzdGljVXBkYXRlT3B0czxULCBBPiB7XG4gIHJ1bihhOiBBLCBzdGF0ZT86IFQpOiBPYnNlcnZhYmxlPEFjdGlvbj4gfCBBY3Rpb24gfCB2b2lkO1xuICB1bmRvQWN0aW9uKGE6IEEsIGU6IGFueSk6IE9ic2VydmFibGU8QWN0aW9uPiB8IEFjdGlvbjtcbn1cblxuLyoqXG4gKiBTZWUge0BsaW5rIERhdGFQZXJzaXN0ZW5jZS5mZXRjaH0gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgRmV0Y2hPcHRzPFQsIEE+IHtcbiAgaWQ/KGE6IEEsIHN0YXRlPzogVCk6IGFueTtcbiAgcnVuKGE6IEEsIHN0YXRlPzogVCk6IE9ic2VydmFibGU8QWN0aW9uPiB8IEFjdGlvbiB8IHZvaWQ7XG4gIG9uRXJyb3I/KGE6IEEsIGU6IGFueSk6IE9ic2VydmFibGU8YW55PiB8IGFueTtcbn1cblxuLyoqXG4gKiBTZWUge0BsaW5rIERhdGFQZXJzaXN0ZW5jZS5uYXZpZ2F0aW9ufSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBIYW5kbGVOYXZpZ2F0aW9uT3B0czxUPiB7XG4gIHJ1bihhOiBBY3RpdmF0ZWRSb3V0ZVNuYXBzaG90LCBzdGF0ZT86IFQpOiBPYnNlcnZhYmxlPEFjdGlvbj4gfCBBY3Rpb24gfCB2b2lkO1xuICBvbkVycm9yPyhhOiBBY3RpdmF0ZWRSb3V0ZVNuYXBzaG90LCBlOiBhbnkpOiBPYnNlcnZhYmxlPGFueT4gfCBhbnk7XG59XG5cbmV4cG9ydCB0eXBlIEFjdGlvbk9yQWN0aW9uV2l0aFN0YXRlPFQsIEE+ID0gQSB8IFtBLCBUXTtcbmV4cG9ydCB0eXBlIEFjdGlvblN0YXRlU3RyZWFtPFQsIEE+ID0gT2JzZXJ2YWJsZTxBY3Rpb25PckFjdGlvbldpdGhTdGF0ZTxULCBBPj47XG5cbmV4cG9ydCBmdW5jdGlvbiBwZXNzaW1pc3RpY1VwZGF0ZTxULCBBIGV4dGVuZHMgQWN0aW9uPihcbiAgb3B0czogUGVzc2ltaXN0aWNVcGRhdGVPcHRzPFQsIEE+XG4pIHtcbiAgcmV0dXJuIChzb3VyY2U6IEFjdGlvblN0YXRlU3RyZWFtPFQsIEE+KTogT2JzZXJ2YWJsZTxBY3Rpb24+ID0+IHtcbiAgICByZXR1cm4gc291cmNlLnBpcGUoXG4gICAgICBtYXBBY3Rpb25BbmRTdGF0ZSgpLFxuICAgICAgY29uY2F0TWFwKHJ1bldpdGhFcnJvckhhbmRsaW5nKG9wdHMucnVuLCBvcHRzLm9uRXJyb3IpKVxuICAgICk7XG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBvcHRpbWlzdGljVXBkYXRlPFQsIEEgZXh0ZW5kcyBBY3Rpb24+KFxuICBvcHRzOiBPcHRpbWlzdGljVXBkYXRlT3B0czxULCBBPlxuKSB7XG4gIHJldHVybiAoc291cmNlOiBBY3Rpb25TdGF0ZVN0cmVhbTxULCBBPik6IE9ic2VydmFibGU8QWN0aW9uPiA9PiB7XG4gICAgcmV0dXJuIHNvdXJjZS5waXBlKFxuICAgICAgbWFwQWN0aW9uQW5kU3RhdGUoKSxcbiAgICAgIGNvbmNhdE1hcChydW5XaXRoRXJyb3JIYW5kbGluZyhvcHRzLnJ1biwgb3B0cy51bmRvQWN0aW9uKSlcbiAgICApO1xuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZmV0Y2g8VCwgQSBleHRlbmRzIEFjdGlvbj4ob3B0czogRmV0Y2hPcHRzPFQsIEE+KSB7XG4gIHJldHVybiAoc291cmNlOiBBY3Rpb25TdGF0ZVN0cmVhbTxULCBBPik6IE9ic2VydmFibGU8QWN0aW9uPiA9PiB7XG4gICAgaWYgKG9wdHMuaWQpIHtcbiAgICAgIGNvbnN0IGdyb3VwZWRGZXRjaGVzID0gc291cmNlLnBpcGUoXG4gICAgICAgIG1hcEFjdGlvbkFuZFN0YXRlKCksXG4gICAgICAgIGdyb3VwQnkoKFthY3Rpb24sIHN0b3JlXSkgPT4ge1xuICAgICAgICAgIHJldHVybiBvcHRzLmlkKGFjdGlvbiwgc3RvcmUpO1xuICAgICAgICB9KVxuICAgICAgKTtcblxuICAgICAgcmV0dXJuIGdyb3VwZWRGZXRjaGVzLnBpcGUoXG4gICAgICAgIG1lcmdlTWFwKHBhaXJzID0+XG4gICAgICAgICAgcGFpcnMucGlwZShzd2l0Y2hNYXAocnVuV2l0aEVycm9ySGFuZGxpbmcob3B0cy5ydW4sIG9wdHMub25FcnJvcikpKVxuICAgICAgICApXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiBzb3VyY2UucGlwZShcbiAgICAgIG1hcEFjdGlvbkFuZFN0YXRlKCksXG4gICAgICBjb25jYXRNYXAocnVuV2l0aEVycm9ySGFuZGxpbmcob3B0cy5ydW4sIG9wdHMub25FcnJvcikpXG4gICAgKTtcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG5hdmlnYXRpb248VCwgQSBleHRlbmRzIEFjdGlvbj4oXG4gIGNvbXBvbmVudDogVHlwZTxhbnk+LFxuICBvcHRzOiBIYW5kbGVOYXZpZ2F0aW9uT3B0czxUPlxuKSB7XG4gIHJldHVybiAoc291cmNlOiBBY3Rpb25TdGF0ZVN0cmVhbTxULCBBPikgPT4ge1xuICAgIGNvbnN0IG5hdiA9IHNvdXJjZS5waXBlKFxuICAgICAgbWFwQWN0aW9uQW5kU3RhdGUoKSxcbiAgICAgIGZpbHRlcigoW2FjdGlvbiwgc3RhdGVdKSA9PiBpc1N0YXRlU25hcHNob3QoYWN0aW9uKSksXG4gICAgICBtYXAoKFthY3Rpb24sIHN0YXRlXSkgPT4ge1xuICAgICAgICBpZiAoIWlzU3RhdGVTbmFwc2hvdChhY3Rpb24pKSB7XG4gICAgICAgICAgLy8gQmVjYXVzZSBvZiB0aGUgYWJvdmUgZmlsdGVyIHdlJ2xsIG5ldmVyIGdldCBoZXJlLFxuICAgICAgICAgIC8vIGJ1dCB0aGlzIHByb3Blcmx5IHR5cGUgbmFycm93cyBgYWN0aW9uYFxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgZmluZFNuYXBzaG90KGNvbXBvbmVudCwgYWN0aW9uLnBheWxvYWQucm91dGVyU3RhdGUucm9vdCksXG4gICAgICAgICAgc3RhdGVcbiAgICAgICAgXSBhcyBbQWN0aXZhdGVkUm91dGVTbmFwc2hvdCwgVF07XG4gICAgICB9KSxcbiAgICAgIGZpbHRlcigoW3NuYXBzaG90LCBzdGF0ZV0pID0+ICEhc25hcHNob3QpXG4gICAgKTtcblxuICAgIHJldHVybiBuYXYucGlwZShzd2l0Y2hNYXAocnVuV2l0aEVycm9ySGFuZGxpbmcob3B0cy5ydW4sIG9wdHMub25FcnJvcikpKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gaXNTdGF0ZVNuYXBzaG90KFxuICBhY3Rpb246IGFueVxuKTogYWN0aW9uIGlzIFJvdXRlck5hdmlnYXRpb25BY3Rpb248Um91dGVyU3RhdGVTbmFwc2hvdD4ge1xuICByZXR1cm4gYWN0aW9uLnR5cGUgPT09IFJPVVRFUl9OQVZJR0FUSU9OO1xufVxuXG5mdW5jdGlvbiBydW5XaXRoRXJyb3JIYW5kbGluZzxULCBBLCBSPihcbiAgcnVuOiAoYTogQSwgc3RhdGU/OiBUKSA9PiBPYnNlcnZhYmxlPFI+IHwgUiB8IHZvaWQsXG4gIG9uRXJyb3I6IGFueVxuKSB7XG4gIHJldHVybiAoW2FjdGlvbiwgc3RhdGVdOiBbQSwgVF0pOiBPYnNlcnZhYmxlPFI+ID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgciA9IHdyYXBJbnRvT2JzZXJ2YWJsZShydW4oYWN0aW9uLCBzdGF0ZSkpO1xuICAgICAgcmV0dXJuIHIucGlwZShjYXRjaEVycm9yKGUgPT4gd3JhcEludG9PYnNlcnZhYmxlKG9uRXJyb3IoYWN0aW9uLCBlKSkpKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gd3JhcEludG9PYnNlcnZhYmxlKG9uRXJyb3IoYWN0aW9uLCBlKSk7XG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIEB3aGF0SXREb2VzIG1hcHMgT2JzZXJ2YWJsZTxBY3Rpb24gfCBbQWN0aW9uLCBTdGF0ZV0+IHRvXG4gKiBPYnNlcnZhYmxlPFtBY3Rpb24sIFN0YXRlXT5cbiAqL1xuZnVuY3Rpb24gbWFwQWN0aW9uQW5kU3RhdGU8VCwgQT4oKSB7XG4gIHJldHVybiAoc291cmNlOiBPYnNlcnZhYmxlPEFjdGlvbk9yQWN0aW9uV2l0aFN0YXRlPFQsIEE+PikgPT4ge1xuICAgIHJldHVybiBzb3VyY2UucGlwZShcbiAgICAgIG1hcCh2YWx1ZSA9PiB7XG4gICAgICAgIGNvbnN0IFthY3Rpb24sIHN0b3JlXSA9IG5vcm1hbGl6ZUFjdGlvbkFuZFN0YXRlKHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIFthY3Rpb24sIHN0b3JlXSBhcyBbQSwgVF07XG4gICAgICB9KVxuICAgICk7XG4gIH07XG59XG5cbi8qKlxuICogQHdoYXRJdERvZXMgTm9ybWFsaXplcyBlaXRoZXIgYSBiYXJlIGFjdGlvbiBvciBhbiBhcnJheSBvZiBhY3Rpb24gYW5kIHN0YXRlXG4gKiBpbnRvIGFuIGFycmF5IG9mIGFjdGlvbiBhbmQgc3RhdGUgKG9yIHVuZGVmaW5lZClcbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplQWN0aW9uQW5kU3RhdGU8VCwgQT4oXG4gIGFyZ3M6IEFjdGlvbk9yQWN0aW9uV2l0aFN0YXRlPFQsIEE+XG4pOiBbQSwgVF0ge1xuICBsZXQgYWN0aW9uOiBBLCBzdGF0ZTogVDtcblxuICBpZiAoYXJncyBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgW2FjdGlvbiwgc3RhdGVdID0gYXJncztcbiAgfSBlbHNlIHtcbiAgICBhY3Rpb24gPSBhcmdzO1xuICB9XG5cbiAgcmV0dXJuIFthY3Rpb24sIHN0YXRlXTtcbn1cblxuLyoqXG4gKiBAd2hhdEl0RG9lcyBQcm92aWRlcyBjb252ZW5pZW5jZSBtZXRob2RzIGZvciBpbXBsZW1lbnRpbmcgY29tbW9uIG9wZXJhdGlvbnMgb2YgcGVyc2lzdGluZyBkYXRhLlxuICovXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgRGF0YVBlcnNpc3RlbmNlPFQ+IHtcbiAgY29uc3RydWN0b3IocHVibGljIHN0b3JlOiBTdG9yZTxUPiwgcHVibGljIGFjdGlvbnM6IEFjdGlvbnMpIHt9XG5cbiAgLyoqXG4gICAqXG4gICAqIEB3aGF0SXREb2VzIEhhbmRsZXMgcGVzc2ltaXN0aWMgdXBkYXRlcyAodXBkYXRpbmcgdGhlIHNlcnZlciBmaXJzdCkuXG4gICAqXG4gICAqIFVwZGF0ZSB0aGUgc2VydmVyIGltcGxlbWVudGVkIG5haXZlbHkgc3VmZmVycyBmcm9tIHJhY2UgY29uZGl0aW9ucyBhbmQgcG9vciBlcnJvciBoYW5kbGluZy5cbiAgICpcbiAgICogYHBlc3NpbWlzdGljVXBkYXRlYCBhZGRyZXNzZXMgdGhlc2UgcHJvYmxlbXMtLWl0IHJ1bnMgYWxsIGZldGNoZXMgaW4gb3JkZXIsIHdoaWNoIHJlbW92ZXMgcmFjZSBjb25kaXRpb25zXG4gICAqIGFuZCBmb3JjZXMgdGhlIGRldmVsb3BlciB0byBoYW5kbGUgZXJyb3JzLlxuICAgKlxuICAgKiAjIyBFeGFtcGxlOlxuICAgKlxuICAgKiBgYGB0eXBlc2NyaXB0XG4gICAqIEBJbmplY3RhYmxlKClcbiAgICogY2xhc3MgVG9kb0VmZmVjdHMge1xuICAgKiAgIEBFZmZlY3QoKSB1cGRhdGVUb2RvID0gdGhpcy5zLnBlc3NpbWlzdGljVXBkYXRlPFVwZGF0ZVRvZG8+KCdVUERBVEVfVE9ETycsIHtcbiAgICogICAgIC8vIHByb3ZpZGVzIGFuIGFjdGlvbiBhbmQgdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIHN0b3JlXG4gICAqICAgICBydW4oYSwgc3RhdGUpIHtcbiAgICogICAgICAgLy8gdXBkYXRlIHRoZSBiYWNrZW5kIGZpcnN0LCBhbmQgdGhlbiBkaXNwYXRjaCBhbiBhY3Rpb24gdGhhdCB3aWxsXG4gICAqICAgICAgIC8vIHVwZGF0ZSB0aGUgY2xpZW50IHNpZGVcbiAgICogICAgICAgcmV0dXJuIHRoaXMuYmFja2VuZChzdGF0ZS51c2VyLCBhLnBheWxvYWQpLm1hcCh1cGRhdGVkID0+ICh7XG4gICAqICAgICAgICAgdHlwZTogJ1RPRE9fVVBEQVRFRCcsXG4gICAqICAgICAgICAgcGF5bG9hZDogdXBkYXRlZFxuICAgKiAgICAgICB9KSk7XG4gICAqICAgICB9LFxuICAgKlxuICAgKiAgICAgb25FcnJvcihhLCBlOiBhbnkpIHtcbiAgICogICAgICAgLy8gd2UgZG9uJ3QgbmVlZCB0byB1bmRvIHRoZSBjaGFuZ2VzIG9uIHRoZSBjbGllbnQgc2lkZS5cbiAgICogICAgICAgLy8gd2UgY2FuIGRpc3BhdGNoIGFuIGVycm9yLCBvciBzaW1wbHkgbG9nIHRoZSBlcnJvciBoZXJlIGFuZCByZXR1cm4gYG51bGxgXG4gICAqICAgICAgIHJldHVybiBudWxsO1xuICAgKiAgICAgfVxuICAgKiAgIH0pO1xuICAgKlxuICAgKiAgIGNvbnN0cnVjdG9yKHByaXZhdGUgczogRGF0YVBlcnNpc3RlbmNlPFRvZG9zU3RhdGU+LCBwcml2YXRlIGJhY2tlbmQ6IEJhY2tlbmQpIHt9XG4gICAqIH1cbiAgICogYGBgXG4gICAqXG4gICAqIE5vdGUgdGhhdCBpZiB5b3UgZG9uJ3QgcmV0dXJuIGEgbmV3IGFjdGlvbiBmcm9tIHRoZSBydW4gY2FsbGJhY2ssIHlvdSBtdXN0IHNldCB0aGUgZGlzcGF0Y2ggcHJvcGVydHlcbiAgICogb2YgdGhlIGVmZmVjdCB0byBmYWxzZSwgbGlrZSB0aGlzOlxuICAgKlxuICAgKiBgYGBcbiAgICogY2xhc3MgVG9kb0VmZmVjdHMge1xuICAgKiAgIEBFZmZlY3Qoe2Rpc3BhdGNoOiBmYWxzZX0pXG4gICAqICAgdXBkYXRlVG9kbzsgLy8uLi5cbiAgICogfVxuICAgKiBgYGBcbiAgICovXG4gIHBlc3NpbWlzdGljVXBkYXRlPEEgZXh0ZW5kcyBBY3Rpb24gPSBBY3Rpb24+KFxuICAgIGFjdGlvblR5cGU6IHN0cmluZyxcbiAgICBvcHRzOiBQZXNzaW1pc3RpY1VwZGF0ZU9wdHM8VCwgQT5cbiAgKTogT2JzZXJ2YWJsZTxhbnk+IHtcbiAgICByZXR1cm4gdGhpcy5hY3Rpb25zLnBpcGUoXG4gICAgICBvZlR5cGU8QT4oYWN0aW9uVHlwZSksXG4gICAgICB3aXRoTGF0ZXN0RnJvbSh0aGlzLnN0b3JlKSxcbiAgICAgIHBlc3NpbWlzdGljVXBkYXRlKG9wdHMpXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAd2hhdEl0RG9lcyBIYW5kbGVzIG9wdGltaXN0aWMgdXBkYXRlcyAodXBkYXRpbmcgdGhlIGNsaWVudCBmaXJzdCkuXG4gICAqXG4gICAqIGBvcHRpbWlzdGljVXBkYXRlYCBhZGRyZXNzZXMgdGhlc2UgcHJvYmxlbXMtLWl0IHJ1bnMgYWxsIGZldGNoZXMgaW4gb3JkZXIsIHdoaWNoIHJlbW92ZXMgcmFjZSBjb25kaXRpb25zXG4gICAqIGFuZCBmb3JjZXMgdGhlIGRldmVsb3BlciB0byBoYW5kbGUgZXJyb3JzLlxuICAgKlxuICAgKiBgb3B0aW1pc3RpY1VwZGF0ZWAgaXMgZGlmZmVyZW50IGZyb20gYHBlc3NpbWlzdGljVXBkYXRlYC4gSW4gY2FzZSBvZiBhIGZhaWx1cmUsIHdoZW4gdXNpbmcgYG9wdGltaXN0aWNVcGRhdGVgLFxuICAgKiB0aGUgZGV2ZWxvcGVyIGFscmVhZHkgdXBkYXRlZCB0aGUgc3RhdGUgbG9jYWxseSwgc28gdGhlIGRldmVsb3BlciBtdXN0IHByb3ZpZGUgYW4gdW5kbyBhY3Rpb24uXG4gICAqXG4gICAqIFRoZSBlcnJvciBoYW5kbGluZyBtdXN0IGJlIGRvbmUgaW4gdGhlIGNhbGxiYWNrLCBvciBieSBtZWFucyBvZiB0aGUgdW5kbyBhY3Rpb24uXG4gICAqXG4gICAqICMjIEV4YW1wbGU6XG4gICAqXG4gICAqIGBgYHR5cGVzY3JpcHRcbiAgICogQEluamVjdGFibGUoKVxuICAgKiBjbGFzcyBUb2RvRWZmZWN0cyB7XG4gICAqICAgQEVmZmVjdCgpIHVwZGF0ZVRvZG8gPSB0aGlzLnMub3B0aW1pc3RpY1VwZGF0ZTxVcGRhdGVUb2RvPignVVBEQVRFX1RPRE8nLCB7XG4gICAqICAgICAvLyBwcm92aWRlcyBhbiBhY3Rpb24gYW5kIHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBzdG9yZVxuICAgKiAgICAgcnVuOiAoYSwgc3RhdGUpID0+IHtcbiAgICogICAgICAgcmV0dXJuIHRoaXMuYmFja2VuZChzdGF0ZS51c2VyLCBhLnBheWxvYWQpO1xuICAgKiAgICAgfSxcbiAgICpcbiAgICogICAgIHVuZG9BY3Rpb246IChhLCBlOiBhbnkpID0+IHtcbiAgICogICAgICAgLy8gZGlzcGF0Y2ggYW4gdW5kbyBhY3Rpb24gdG8gdW5kbyB0aGUgY2hhbmdlcyBpbiB0aGUgY2xpZW50IHN0YXRlXG4gICAqICAgICAgIHJldHVybiAoe1xuICAgKiAgICAgICAgIHR5cGU6ICdVTkRPX1VQREFURV9UT0RPJyxcbiAgICogICAgICAgICBwYXlsb2FkOiBhXG4gICAqICAgICAgIH0pO1xuICAgKiAgICAgfVxuICAgKiAgIH0pO1xuICAgKlxuICAgKiAgIGNvbnN0cnVjdG9yKHByaXZhdGUgczogRGF0YVBlcnNpc3RlbmNlPFRvZG9zU3RhdGU+LCBwcml2YXRlIGJhY2tlbmQ6IEJhY2tlbmQpIHt9XG4gICAqIH1cbiAgICogYGBgXG4gICAqXG4gICAqIE5vdGUgdGhhdCBpZiB5b3UgZG9uJ3QgcmV0dXJuIGEgbmV3IGFjdGlvbiBmcm9tIHRoZSBydW4gY2FsbGJhY2ssIHlvdSBtdXN0IHNldCB0aGUgZGlzcGF0Y2ggcHJvcGVydHlcbiAgICogb2YgdGhlIGVmZmVjdCB0byBmYWxzZSwgbGlrZSB0aGlzOlxuICAgKlxuICAgKiBgYGBcbiAgICogY2xhc3MgVG9kb0VmZmVjdHMge1xuICAgKiAgIEBFZmZlY3Qoe2Rpc3BhdGNoOiBmYWxzZX0pXG4gICAqICAgdXBkYXRlVG9kbzsgLy8uLi5cbiAgICogfVxuICAgKiBgYGBcbiAgICovXG4gIG9wdGltaXN0aWNVcGRhdGU8QSBleHRlbmRzIEFjdGlvbiA9IEFjdGlvbj4oXG4gICAgYWN0aW9uVHlwZTogc3RyaW5nLFxuICAgIG9wdHM6IE9wdGltaXN0aWNVcGRhdGVPcHRzPFQsIEE+XG4gICk6IE9ic2VydmFibGU8YW55PiB7XG4gICAgcmV0dXJuIHRoaXMuYWN0aW9ucy5waXBlKFxuICAgICAgb2ZUeXBlPEE+KGFjdGlvblR5cGUpLFxuICAgICAgd2l0aExhdGVzdEZyb20odGhpcy5zdG9yZSksXG4gICAgICBvcHRpbWlzdGljVXBkYXRlKG9wdHMpXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAd2hhdEl0RG9lcyBIYW5kbGVzIGRhdGEgZmV0Y2hpbmcuXG4gICAqXG4gICAqIERhdGEgZmV0Y2hpbmcgaW1wbGVtZW50ZWQgbmFpdmVseSBzdWZmZXJzIGZyb20gcmFjZSBjb25kaXRpb25zIGFuZCBwb29yIGVycm9yIGhhbmRsaW5nLlxuICAgKlxuICAgKiBgZmV0Y2hgIGFkZHJlc3NlcyB0aGVzZSBwcm9ibGVtcy0taXQgcnVucyBhbGwgZmV0Y2hlcyBpbiBvcmRlciwgd2hpY2ggcmVtb3ZlcyByYWNlIGNvbmRpdGlvbnNcbiAgICogYW5kIGZvcmNlcyB0aGUgZGV2ZWxvcGVyIHRvIGhhbmRsZSBlcnJvcnMuXG4gICAqXG4gICAqICMjIEV4YW1wbGU6XG4gICAqXG4gICAqIGBgYHR5cGVzY3JpcHRcbiAgICogQEluamVjdGFibGUoKVxuICAgKiBjbGFzcyBUb2RvRWZmZWN0cyB7XG4gICAqICAgQEVmZmVjdCgpIGxvYWRUb2RvcyA9IHRoaXMucy5mZXRjaDxHZXRUb2Rvcz4oJ0dFVF9UT0RPUycsIHtcbiAgICogICAgIC8vIHByb3ZpZGVzIGFuIGFjdGlvbiBhbmQgdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIHN0b3JlXG4gICAqICAgICBydW46IChhLCBzdGF0ZSkgPT4ge1xuICAgKiAgICAgICByZXR1cm4gdGhpcy5iYWNrZW5kKHN0YXRlLnVzZXIsIGEucGF5bG9hZCkubWFwKHIgPT4gKHtcbiAgICogICAgICAgICB0eXBlOiAnVE9ET1MnLFxuICAgKiAgICAgICAgIHBheWxvYWQ6IHJcbiAgICogICAgICAgfSk7XG4gICAqICAgICB9LFxuICAgKlxuICAgKiAgICAgb25FcnJvcjogKGEsIGU6IGFueSkgPT4ge1xuICAgKiAgICAgICAvLyBkaXNwYXRjaCBhbiB1bmRvIGFjdGlvbiB0byB1bmRvIHRoZSBjaGFuZ2VzIGluIHRoZSBjbGllbnQgc3RhdGVcbiAgICogICAgIH1cbiAgICogICB9KTtcbiAgICpcbiAgICogICBjb25zdHJ1Y3Rvcihwcml2YXRlIHM6IERhdGFQZXJzaXN0ZW5jZTxUb2Rvc1N0YXRlPiwgcHJpdmF0ZSBiYWNrZW5kOiBCYWNrZW5kKSB7fVxuICAgKiB9XG4gICAqIGBgYFxuICAgKlxuICAgKiBUaGlzIGlzIGNvcnJlY3QsIGJ1dCBiZWNhdXNlIGl0IHNldCB0aGUgY29uY3VycmVuY3kgdG8gMSwgaXQgbWF5IG5vdCBiZSBwZXJmb3JtYW50LlxuICAgKlxuICAgKiBUbyBmaXggdGhhdCwgeW91IGNhbiBwcm92aWRlIHRoZSBgaWRgIGZ1bmN0aW9uLCBsaWtlIHRoaXM6XG4gICAqXG4gICAqIGBgYHR5cGVzY3JpcHRcbiAgICogQEluamVjdGFibGUoKVxuICAgKiBjbGFzcyBUb2RvRWZmZWN0cyB7XG4gICAqICAgQEVmZmVjdCgpIGxvYWRUb2RvID0gdGhpcy5zLmZldGNoPEdldFRvZG8+KCdHRVRfVE9ETycsIHtcbiAgICogICAgIGlkOiAoYSwgc3RhdGUpID0+IHtcbiAgICogICAgICAgcmV0dXJuIGEucGF5bG9hZC5pZDtcbiAgICogICAgIH1cbiAgICpcbiAgICogICAgIC8vIHByb3ZpZGVzIGFuIGFjdGlvbiBhbmQgdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIHN0b3JlXG4gICAqICAgICBydW46IChhLCBzdGF0ZSkgPT4ge1xuICAgKiAgICAgICByZXR1cm4gdGhpcy5iYWNrZW5kKHN0YXRlLnVzZXIsIGEucGF5bG9hZCkubWFwKHIgPT4gKHtcbiAgICogICAgICAgICB0eXBlOiAnVE9ETycsXG4gICAqICAgICAgICAgcGF5bG9hZDogclxuICAgKiAgICAgICB9KTtcbiAgICogICAgIH0sXG4gICAqXG4gICAqICAgICBvbkVycm9yOiAoYSwgZTogYW55KSA9PiB7XG4gICAqICAgICAgIC8vIGRpc3BhdGNoIGFuIHVuZG8gYWN0aW9uIHRvIHVuZG8gdGhlIGNoYW5nZXMgaW4gdGhlIGNsaWVudCBzdGF0ZVxuICAgKiAgICAgICByZXR1cm4gbnVsbDtcbiAgICogICAgIH1cbiAgICogICB9KTtcbiAgICpcbiAgICogICBjb25zdHJ1Y3Rvcihwcml2YXRlIHM6IERhdGFQZXJzaXN0ZW5jZTxUb2Rvc1N0YXRlPiwgcHJpdmF0ZSBiYWNrZW5kOiBCYWNrZW5kKSB7fVxuICAgKiB9XG4gICAqIGBgYFxuICAgKlxuICAgKiBXaXRoIHRoaXMgc2V0dXAsIHRoZSByZXF1ZXN0cyBmb3IgVG9kbyAxIHdpbGwgcnVuIGNvbmN1cnJlbnRseSB3aXRoIHRoZSByZXF1ZXN0cyBmb3IgVG9kbyAyLlxuICAgKlxuICAgKiBJbiBhZGRpdGlvbiwgaWYgRGF0YVBlcnNpc3RlbmNlIG5vdGljZXMgdGhhdCB0aGVyZSBhcmUgbXVsdGlwbGUgcmVxdWVzdHMgZm9yIFRvZG8gMSBzY2hlZHVsZWQsXG4gICAqIGl0IHdpbGwgb25seSBydW4gdGhlIGxhc3Qgb25lLlxuICAgKi9cbiAgZmV0Y2g8QSBleHRlbmRzIEFjdGlvbiA9IEFjdGlvbj4oXG4gICAgYWN0aW9uVHlwZTogc3RyaW5nLFxuICAgIG9wdHM6IEZldGNoT3B0czxULCBBPlxuICApOiBPYnNlcnZhYmxlPGFueT4ge1xuICAgIHJldHVybiB0aGlzLmFjdGlvbnMucGlwZShcbiAgICAgIG9mVHlwZTxBPihhY3Rpb25UeXBlKSxcbiAgICAgIHdpdGhMYXRlc3RGcm9tKHRoaXMuc3RvcmUpLFxuICAgICAgZmV0Y2gob3B0cylcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEB3aGF0SXREb2VzIEhhbmRsZXMgZGF0YSBmZXRjaGluZyBhcyBwYXJ0IG9mIHJvdXRlciBuYXZpZ2F0aW9uLlxuICAgKlxuICAgKiBEYXRhIGZldGNoaW5nIGltcGxlbWVudGVkIG5haXZlbHkgc3VmZmVycyBmcm9tIHJhY2UgY29uZGl0aW9ucyBhbmQgcG9vciBlcnJvciBoYW5kbGluZy5cbiAgICpcbiAgICogYG5hdmlnYXRpb25gIGFkZHJlc3NlcyB0aGVzZSBwcm9ibGVtcy5cbiAgICpcbiAgICogSXQgY2hlY2tzIGlmIGFuIGFjdGl2YXRlZCByb3V0ZXIgc3RhdGUgY29udGFpbnMgdGhlIHBhc3NlZCBpbiBjb21wb25lbnQgdHlwZSwgYW5kLCBpZiBpdCBkb2VzLCBydW5zIHRoZSBgcnVuYFxuICAgKiBjYWxsYmFjay4gSXQgcHJvdmlkZXMgdGhlIGFjdGl2YXRlZCBzbmFwc2hvdCBhc3NvY2lhdGVkIHdpdGggdGhlIGNvbXBvbmVudCBhbmQgdGhlIGN1cnJlbnQgc3RhdGUuIEFuZCBpdCBvbmx5IHJ1bnNcbiAgICogdGhlIGxhc3QgcmVxdWVzdC5cbiAgICpcbiAgICogIyMgRXhhbXBsZTpcbiAgICpcbiAgICogYGBgdHlwZXNjcmlwdFxuICAgKiBASW5qZWN0YWJsZSgpXG4gICAqIGNsYXNzIFRvZG9FZmZlY3RzIHtcbiAgICogICBARWZmZWN0KCkgbG9hZFRvZG8gPSB0aGlzLnMubmF2aWdhdGlvbihUb2RvQ29tcG9uZW50LCB7XG4gICAqICAgICBydW46IChhLCBzdGF0ZSkgPT4ge1xuICAgKiAgICAgICByZXR1cm4gdGhpcy5iYWNrZW5kLmZldGNoVG9kbyhhLnBhcmFtc1snaWQnXSkubWFwKHRvZG8gPT4gKHtcbiAgICogICAgICAgICB0eXBlOiAnVE9ET19MT0FERUQnLFxuICAgKiAgICAgICAgIHBheWxvYWQ6IHRvZG9cbiAgICogICAgICAgfSkpO1xuICAgKiAgICAgfSxcbiAgICogICAgIG9uRXJyb3I6IChhLCBlOiBhbnkpID0+IHtcbiAgICogICAgICAgLy8gd2UgY2FuIGxvZyBhbmQgZXJyb3IgaGVyZSBhbmQgcmV0dXJuIG51bGxcbiAgICogICAgICAgLy8gd2UgY2FuIGFsc28gbmF2aWdhdGUgYmFja1xuICAgKiAgICAgICByZXR1cm4gbnVsbDtcbiAgICogICAgIH1cbiAgICogICB9KTtcbiAgICogICBjb25zdHJ1Y3Rvcihwcml2YXRlIHM6IERhdGFQZXJzaXN0ZW5jZTxUb2Rvc1N0YXRlPiwgcHJpdmF0ZSBiYWNrZW5kOiBCYWNrZW5kKSB7fVxuICAgKiB9XG4gICAqIGBgYFxuICAgKi9cbiAgbmF2aWdhdGlvbihcbiAgICBjb21wb25lbnQ6IFR5cGU8YW55PixcbiAgICBvcHRzOiBIYW5kbGVOYXZpZ2F0aW9uT3B0czxUPlxuICApOiBPYnNlcnZhYmxlPGFueT4ge1xuICAgIHJldHVybiB0aGlzLmFjdGlvbnMucGlwZShcbiAgICAgIHdpdGhMYXRlc3RGcm9tKHRoaXMuc3RvcmUpLFxuICAgICAgbmF2aWdhdGlvbihjb21wb25lbnQsIG9wdHMpXG4gICAgKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmaW5kU25hcHNob3QoXG4gIGNvbXBvbmVudDogVHlwZTxhbnk+LFxuICBzOiBBY3RpdmF0ZWRSb3V0ZVNuYXBzaG90XG4pOiBBY3RpdmF0ZWRSb3V0ZVNuYXBzaG90IHtcbiAgaWYgKHMucm91dGVDb25maWcgJiYgcy5yb3V0ZUNvbmZpZy5jb21wb25lbnQgPT09IGNvbXBvbmVudCkge1xuICAgIHJldHVybiBzO1xuICB9XG4gIGZvciAoY29uc3QgYyBvZiBzLmNoaWxkcmVuKSB7XG4gICAgY29uc3Qgc3MgPSBmaW5kU25hcHNob3QoY29tcG9uZW50LCBjKTtcbiAgICBpZiAoc3MpIHtcbiAgICAgIHJldHVybiBzcztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIHdyYXBJbnRvT2JzZXJ2YWJsZTxPPihvYmo6IE9ic2VydmFibGU8Tz4gfCBPIHwgdm9pZCk6IE9ic2VydmFibGU8Tz4ge1xuICBpZiAoISFvYmogJiYgb2JqIGluc3RhbmNlb2YgT2JzZXJ2YWJsZSkge1xuICAgIHJldHVybiBvYmo7XG4gIH0gZWxzZSBpZiAoIW9iaikge1xuICAgIHJldHVybiBvZigpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBvZihvYmogYXMgTyk7XG4gIH1cbn1cbiJdfQ==