(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('@ngrx/effects'), require('@ngrx/router-store'), require('@ngrx/store'), require('rxjs'), require('rxjs/operators')) :
    typeof define === 'function' && define.amd ? define('@nrwl/nx', ['exports', '@angular/core', '@ngrx/effects', '@ngrx/router-store', '@ngrx/store', 'rxjs', 'rxjs/operators'], factory) :
    (factory((global.nrwl = global.nrwl || {}, global.nrwl.nx = {}),global.ng.core,global.ngrx.effects,global.ngrx.routerStore,global.ngrx.store,global.rxjs,global.rxjs.operators));
}(this, (function (exports,core,effects,routerStore,store,rxjs,operators) { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    function __values(o) {
        var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
        if (m)
            return m.call(o);
        return {
            next: function () {
                if (o && i >= o.length)
                    o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
    }
    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
            return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
                ar.push(r.value);
        }
        catch (error) {
            e = { error: error };
        }
        finally {
            try {
                if (r && !r.done && (m = i["return"]))
                    m.call(i);
            }
            finally {
                if (e)
                    throw e.error;
            }
        }
        return ar;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * @template T, A
     * @param {?} opts
     * @return {?}
     */
    function pessimisticUpdate(opts) {
        return function (source) {
            return source.pipe(mapActionAndState(), operators.concatMap(runWithErrorHandling(opts.run, opts.onError)));
        };
    }
    /**
     * @template T, A
     * @param {?} opts
     * @return {?}
     */
    function optimisticUpdate(opts) {
        return function (source) {
            return source.pipe(mapActionAndState(), operators.concatMap(runWithErrorHandling(opts.run, opts.undoAction)));
        };
    }
    /**
     * @template T, A
     * @param {?} opts
     * @return {?}
     */
    function fetch(opts) {
        return function (source) {
            if (opts.id) {
                /** @type {?} */
                var groupedFetches = source.pipe(mapActionAndState(), operators.groupBy(function (_a) {
                    var _b = __read(_a, 2), action = _b[0], store$$1 = _b[1];
                    return opts.id(action, store$$1);
                }));
                return groupedFetches.pipe(operators.mergeMap(function (pairs) {
                    return pairs.pipe(operators.switchMap(runWithErrorHandling(opts.run, opts.onError)));
                }));
            }
            return source.pipe(mapActionAndState(), operators.concatMap(runWithErrorHandling(opts.run, opts.onError)));
        };
    }
    /**
     * @template T, A
     * @param {?} component
     * @param {?} opts
     * @return {?}
     */
    function navigation(component, opts) {
        return function (source) {
            /** @type {?} */
            var nav = source.pipe(mapActionAndState(), operators.filter(function (_a) {
                var _b = __read(_a, 2), action = _b[0], state = _b[1];
                return isStateSnapshot(action);
            }), operators.map(function (_a) {
                var _b = __read(_a, 2), action = _b[0], state = _b[1];
                if (!isStateSnapshot(action)) {
                    // Because of the above filter we'll never get here,
                    // but this properly type narrows `action`
                    return;
                }
                return ( /** @type {?} */([
                    findSnapshot(component, action.payload.routerState.root),
                    state
                ]));
            }), operators.filter(function (_a) {
                var _b = __read(_a, 2), snapshot = _b[0], state = _b[1];
                return !!snapshot;
            }));
            return nav.pipe(operators.switchMap(runWithErrorHandling(opts.run, opts.onError)));
        };
    }
    /**
     * @param {?} action
     * @return {?}
     */
    function isStateSnapshot(action) {
        return action.type === routerStore.ROUTER_NAVIGATION;
    }
    /**
     * @template T, A, R
     * @param {?} run
     * @param {?} onError
     * @return {?}
     */
    function runWithErrorHandling(run, onError) {
        return function (_a) {
            var _b = __read(_a, 2), action = _b[0], state = _b[1];
            try {
                /** @type {?} */
                var r = wrapIntoObservable(run(action, state));
                return r.pipe(operators.catchError(function (e) { return wrapIntoObservable(onError(action, e)); }));
            }
            catch (e) {
                return wrapIntoObservable(onError(action, e));
            }
        };
    }
    /**
     * \@whatItDoes maps Observable<Action | [Action, State]> to
     * Observable<[Action, State]>
     * @template T, A
     * @return {?}
     */
    function mapActionAndState() {
        return function (source) {
            return source.pipe(operators.map(function (value) {
                var _a = __read(normalizeActionAndState(value), 2), action = _a[0], store$$1 = _a[1];
                return ( /** @type {?} */([action, store$$1]));
            }));
        };
    }
    /**
     * \@whatItDoes Normalizes either a bare action or an array of action and state
     * into an array of action and state (or undefined)
     * @template T, A
     * @param {?} args
     * @return {?}
     */
    function normalizeActionAndState(args) {
        var _a;
        /** @type {?} */
        var action;
        /** @type {?} */
        var state;
        if (args instanceof Array) {
            _a = __read(args, 2), action = _a[0], state = _a[1];
        }
        else {
            action = args;
        }
        return [action, state];
    }
    /**
     * \@whatItDoes Provides convenience methods for implementing common operations of persisting data.
     * @template T
     */
    var DataPersistence = /** @class */ (function () {
        function DataPersistence(store$$1, actions) {
            this.store = store$$1;
            this.actions = actions;
        }
        /**
         *
         * @whatItDoes Handles pessimistic updates (updating the server first).
         *
         * Update the server implemented naively suffers from race conditions and poor error handling.
         *
         * `pessimisticUpdate` addresses these problems--it runs all fetches in order, which removes race conditions
         * and forces the developer to handle errors.
         *
         * ## Example:
         *
         * ```typescript
         * @Injectable()
         * class TodoEffects {
         *   @Effect() updateTodo = this.s.pessimisticUpdate<UpdateTodo>('UPDATE_TODO', {
         *     // provides an action and the current state of the store
         *     run(a, state) {
         *       // update the backend first, and then dispatch an action that will
         *       // update the client side
         *       return this.backend(state.user, a.payload).map(updated => ({
         *         type: 'TODO_UPDATED',
         *         payload: updated
         *       }));
         *     },
         *
         *     onError(a, e: any) {
         *       // we don't need to undo the changes on the client side.
         *       // we can dispatch an error, or simply log the error here and return `null`
         *       return null;
         *     }
         *   });
         *
         *   constructor(private s: DataPersistence<TodosState>, private backend: Backend) {}
         * }
         * ```
         *
         * Note that if you don't return a new action from the run callback, you must set the dispatch property
         * of the effect to false, like this:
         *
         * ```
         * class TodoEffects {
         *   @Effect({dispatch: false})
         *   updateTodo; //...
         * }
         * ```
         */
        /**
         *
         * \@whatItDoes Handles pessimistic updates (updating the server first).
         *
         * Update the server implemented naively suffers from race conditions and poor error handling.
         *
         * `pessimisticUpdate` addresses these problems--it runs all fetches in order, which removes race conditions
         * and forces the developer to handle errors.
         *
         * ## Example:
         *
         * ```typescript
         * \@Injectable()
         * class TodoEffects {
         * \@Effect() updateTodo = this.s.pessimisticUpdate<UpdateTodo>('UPDATE_TODO', {
         *     // provides an action and the current state of the store
         *     run(a, state) {
         *       // update the backend first, and then dispatch an action that will
         *       // update the client side
         *       return this.backend(state.user, a.payload).map(updated => ({
         *         type: 'TODO_UPDATED',
         *         payload: updated
         *       }));
         *     },
         *
         *     onError(a, e: any) {
         *       // we don't need to undo the changes on the client side.
         *       // we can dispatch an error, or simply log the error here and return `null`
         *       return null;
         *     }
         *   });
         *
         *   constructor(private s: DataPersistence<TodosState>, private backend: Backend) {}
         * }
         * ```
         *
         * Note that if you don't return a new action from the run callback, you must set the dispatch property
         * of the effect to false, like this:
         *
         * ```
         * class TodoEffects {
         * \@Effect({dispatch: false})
         *   updateTodo; //...
         * }
         * ```
         * @template A
         * @param {?} actionType
         * @param {?} opts
         * @return {?}
         */
        DataPersistence.prototype.pessimisticUpdate = /**
         *
         * \@whatItDoes Handles pessimistic updates (updating the server first).
         *
         * Update the server implemented naively suffers from race conditions and poor error handling.
         *
         * `pessimisticUpdate` addresses these problems--it runs all fetches in order, which removes race conditions
         * and forces the developer to handle errors.
         *
         * ## Example:
         *
         * ```typescript
         * \@Injectable()
         * class TodoEffects {
         * \@Effect() updateTodo = this.s.pessimisticUpdate<UpdateTodo>('UPDATE_TODO', {
         *     // provides an action and the current state of the store
         *     run(a, state) {
         *       // update the backend first, and then dispatch an action that will
         *       // update the client side
         *       return this.backend(state.user, a.payload).map(updated => ({
         *         type: 'TODO_UPDATED',
         *         payload: updated
         *       }));
         *     },
         *
         *     onError(a, e: any) {
         *       // we don't need to undo the changes on the client side.
         *       // we can dispatch an error, or simply log the error here and return `null`
         *       return null;
         *     }
         *   });
         *
         *   constructor(private s: DataPersistence<TodosState>, private backend: Backend) {}
         * }
         * ```
         *
         * Note that if you don't return a new action from the run callback, you must set the dispatch property
         * of the effect to false, like this:
         *
         * ```
         * class TodoEffects {
         * \@Effect({dispatch: false})
         *   updateTodo; //...
         * }
         * ```
         * @template A
         * @param {?} actionType
         * @param {?} opts
         * @return {?}
         */
            function (actionType, opts) {
                return this.actions.pipe(effects.ofType(actionType), operators.withLatestFrom(this.store), pessimisticUpdate(opts));
            };
        /**
         *
         * @whatItDoes Handles optimistic updates (updating the client first).
         *
         * `optimisticUpdate` addresses these problems--it runs all fetches in order, which removes race conditions
         * and forces the developer to handle errors.
         *
         * `optimisticUpdate` is different from `pessimisticUpdate`. In case of a failure, when using `optimisticUpdate`,
         * the developer already updated the state locally, so the developer must provide an undo action.
         *
         * The error handling must be done in the callback, or by means of the undo action.
         *
         * ## Example:
         *
         * ```typescript
         * @Injectable()
         * class TodoEffects {
         *   @Effect() updateTodo = this.s.optimisticUpdate<UpdateTodo>('UPDATE_TODO', {
         *     // provides an action and the current state of the store
         *     run: (a, state) => {
         *       return this.backend(state.user, a.payload);
         *     },
         *
         *     undoAction: (a, e: any) => {
         *       // dispatch an undo action to undo the changes in the client state
         *       return ({
         *         type: 'UNDO_UPDATE_TODO',
         *         payload: a
         *       });
         *     }
         *   });
         *
         *   constructor(private s: DataPersistence<TodosState>, private backend: Backend) {}
         * }
         * ```
         *
         * Note that if you don't return a new action from the run callback, you must set the dispatch property
         * of the effect to false, like this:
         *
         * ```
         * class TodoEffects {
         *   @Effect({dispatch: false})
         *   updateTodo; //...
         * }
         * ```
         */
        /**
         *
         * \@whatItDoes Handles optimistic updates (updating the client first).
         *
         * `optimisticUpdate` addresses these problems--it runs all fetches in order, which removes race conditions
         * and forces the developer to handle errors.
         *
         * `optimisticUpdate` is different from `pessimisticUpdate`. In case of a failure, when using `optimisticUpdate`,
         * the developer already updated the state locally, so the developer must provide an undo action.
         *
         * The error handling must be done in the callback, or by means of the undo action.
         *
         * ## Example:
         *
         * ```typescript
         * \@Injectable()
         * class TodoEffects {
         * \@Effect() updateTodo = this.s.optimisticUpdate<UpdateTodo>('UPDATE_TODO', {
         *     // provides an action and the current state of the store
         *     run: (a, state) => {
         *       return this.backend(state.user, a.payload);
         *     },
         *
         *     undoAction: (a, e: any) => {
         *       // dispatch an undo action to undo the changes in the client state
         *       return ({
         *         type: 'UNDO_UPDATE_TODO',
         *         payload: a
         *       });
         *     }
         *   });
         *
         *   constructor(private s: DataPersistence<TodosState>, private backend: Backend) {}
         * }
         * ```
         *
         * Note that if you don't return a new action from the run callback, you must set the dispatch property
         * of the effect to false, like this:
         *
         * ```
         * class TodoEffects {
         * \@Effect({dispatch: false})
         *   updateTodo; //...
         * }
         * ```
         * @template A
         * @param {?} actionType
         * @param {?} opts
         * @return {?}
         */
        DataPersistence.prototype.optimisticUpdate = /**
         *
         * \@whatItDoes Handles optimistic updates (updating the client first).
         *
         * `optimisticUpdate` addresses these problems--it runs all fetches in order, which removes race conditions
         * and forces the developer to handle errors.
         *
         * `optimisticUpdate` is different from `pessimisticUpdate`. In case of a failure, when using `optimisticUpdate`,
         * the developer already updated the state locally, so the developer must provide an undo action.
         *
         * The error handling must be done in the callback, or by means of the undo action.
         *
         * ## Example:
         *
         * ```typescript
         * \@Injectable()
         * class TodoEffects {
         * \@Effect() updateTodo = this.s.optimisticUpdate<UpdateTodo>('UPDATE_TODO', {
         *     // provides an action and the current state of the store
         *     run: (a, state) => {
         *       return this.backend(state.user, a.payload);
         *     },
         *
         *     undoAction: (a, e: any) => {
         *       // dispatch an undo action to undo the changes in the client state
         *       return ({
         *         type: 'UNDO_UPDATE_TODO',
         *         payload: a
         *       });
         *     }
         *   });
         *
         *   constructor(private s: DataPersistence<TodosState>, private backend: Backend) {}
         * }
         * ```
         *
         * Note that if you don't return a new action from the run callback, you must set the dispatch property
         * of the effect to false, like this:
         *
         * ```
         * class TodoEffects {
         * \@Effect({dispatch: false})
         *   updateTodo; //...
         * }
         * ```
         * @template A
         * @param {?} actionType
         * @param {?} opts
         * @return {?}
         */
            function (actionType, opts) {
                return this.actions.pipe(effects.ofType(actionType), operators.withLatestFrom(this.store), optimisticUpdate(opts));
            };
        /**
         *
         * @whatItDoes Handles data fetching.
         *
         * Data fetching implemented naively suffers from race conditions and poor error handling.
         *
         * `fetch` addresses these problems--it runs all fetches in order, which removes race conditions
         * and forces the developer to handle errors.
         *
         * ## Example:
         *
         * ```typescript
         * @Injectable()
         * class TodoEffects {
         *   @Effect() loadTodos = this.s.fetch<GetTodos>('GET_TODOS', {
         *     // provides an action and the current state of the store
         *     run: (a, state) => {
         *       return this.backend(state.user, a.payload).map(r => ({
         *         type: 'TODOS',
         *         payload: r
         *       });
         *     },
         *
         *     onError: (a, e: any) => {
         *       // dispatch an undo action to undo the changes in the client state
         *     }
         *   });
         *
         *   constructor(private s: DataPersistence<TodosState>, private backend: Backend) {}
         * }
         * ```
         *
         * This is correct, but because it set the concurrency to 1, it may not be performant.
         *
         * To fix that, you can provide the `id` function, like this:
         *
         * ```typescript
         * @Injectable()
         * class TodoEffects {
         *   @Effect() loadTodo = this.s.fetch<GetTodo>('GET_TODO', {
         *     id: (a, state) => {
         *       return a.payload.id;
         *     }
         *
         *     // provides an action and the current state of the store
         *     run: (a, state) => {
         *       return this.backend(state.user, a.payload).map(r => ({
         *         type: 'TODO',
         *         payload: r
         *       });
         *     },
         *
         *     onError: (a, e: any) => {
         *       // dispatch an undo action to undo the changes in the client state
         *       return null;
         *     }
         *   });
         *
         *   constructor(private s: DataPersistence<TodosState>, private backend: Backend) {}
         * }
         * ```
         *
         * With this setup, the requests for Todo 1 will run concurrently with the requests for Todo 2.
         *
         * In addition, if DataPersistence notices that there are multiple requests for Todo 1 scheduled,
         * it will only run the last one.
         */
        /**
         *
         * \@whatItDoes Handles data fetching.
         *
         * Data fetching implemented naively suffers from race conditions and poor error handling.
         *
         * `fetch` addresses these problems--it runs all fetches in order, which removes race conditions
         * and forces the developer to handle errors.
         *
         * ## Example:
         *
         * ```typescript
         * \@Injectable()
         * class TodoEffects {
         * \@Effect() loadTodos = this.s.fetch<GetTodos>('GET_TODOS', {
         *     // provides an action and the current state of the store
         *     run: (a, state) => {
         *       return this.backend(state.user, a.payload).map(r => ({
         *         type: 'TODOS',
         *         payload: r
         *       });
         *     },
         *
         *     onError: (a, e: any) => {
         *       // dispatch an undo action to undo the changes in the client state
         *     }
         *   });
         *
         *   constructor(private s: DataPersistence<TodosState>, private backend: Backend) {}
         * }
         * ```
         *
         * This is correct, but because it set the concurrency to 1, it may not be performant.
         *
         * To fix that, you can provide the `id` function, like this:
         *
         * ```typescript / loadTodo = this.s.fetch<GetTodo>('GET_TODO', {
         *     id: (a, state) => {
         *       return a.payload.id;
         *     }
         *
         *     // provides an action and the current state of the store
         *     run: (a, state) => {
         *       return this.backend(state.user, a.payload).map(r => ({
         *         type: 'TODO',
         *         payload: r
         *       });
         *     },
         *
         *     onError: (a, e: any) => {
         *       // dispatch an undo action to undo the changes in the client state
         *       return null;
         *     }
         *   });
         *
         *   constructor(private s: DataPersistence<TodosState>, private backend: Backend) {}
         * }
         * ```
         *
         * With this setup, the requests for Todo 1 will run concurrently with the requests for Todo 2.
         *
         * In addition, if DataPersistence notices that there are multiple requests for Todo 1 scheduled,
         * it will only run the last one.
         * @template A
         * @param {?} actionType
         * @param {?} opts
         * @return {?}
         */
        DataPersistence.prototype.fetch = /**
         *
         * \@whatItDoes Handles data fetching.
         *
         * Data fetching implemented naively suffers from race conditions and poor error handling.
         *
         * `fetch` addresses these problems--it runs all fetches in order, which removes race conditions
         * and forces the developer to handle errors.
         *
         * ## Example:
         *
         * ```typescript
         * \@Injectable()
         * class TodoEffects {
         * \@Effect() loadTodos = this.s.fetch<GetTodos>('GET_TODOS', {
         *     // provides an action and the current state of the store
         *     run: (a, state) => {
         *       return this.backend(state.user, a.payload).map(r => ({
         *         type: 'TODOS',
         *         payload: r
         *       });
         *     },
         *
         *     onError: (a, e: any) => {
         *       // dispatch an undo action to undo the changes in the client state
         *     }
         *   });
         *
         *   constructor(private s: DataPersistence<TodosState>, private backend: Backend) {}
         * }
         * ```
         *
         * This is correct, but because it set the concurrency to 1, it may not be performant.
         *
         * To fix that, you can provide the `id` function, like this:
         *
         * ```typescript / loadTodo = this.s.fetch<GetTodo>('GET_TODO', {
         *     id: (a, state) => {
         *       return a.payload.id;
         *     }
         *
         *     // provides an action and the current state of the store
         *     run: (a, state) => {
         *       return this.backend(state.user, a.payload).map(r => ({
         *         type: 'TODO',
         *         payload: r
         *       });
         *     },
         *
         *     onError: (a, e: any) => {
         *       // dispatch an undo action to undo the changes in the client state
         *       return null;
         *     }
         *   });
         *
         *   constructor(private s: DataPersistence<TodosState>, private backend: Backend) {}
         * }
         * ```
         *
         * With this setup, the requests for Todo 1 will run concurrently with the requests for Todo 2.
         *
         * In addition, if DataPersistence notices that there are multiple requests for Todo 1 scheduled,
         * it will only run the last one.
         * @template A
         * @param {?} actionType
         * @param {?} opts
         * @return {?}
         */
            function (actionType, opts) {
                return this.actions.pipe(effects.ofType(actionType), operators.withLatestFrom(this.store), fetch(opts));
            };
        /**
         * @whatItDoes Handles data fetching as part of router navigation.
         *
         * Data fetching implemented naively suffers from race conditions and poor error handling.
         *
         * `navigation` addresses these problems.
         *
         * It checks if an activated router state contains the passed in component type, and, if it does, runs the `run`
         * callback. It provides the activated snapshot associated with the component and the current state. And it only runs
         * the last request.
         *
         * ## Example:
         *
         * ```typescript
         * @Injectable()
         * class TodoEffects {
         *   @Effect() loadTodo = this.s.navigation(TodoComponent, {
         *     run: (a, state) => {
         *       return this.backend.fetchTodo(a.params['id']).map(todo => ({
         *         type: 'TODO_LOADED',
         *         payload: todo
         *       }));
         *     },
         *     onError: (a, e: any) => {
         *       // we can log and error here and return null
         *       // we can also navigate back
         *       return null;
         *     }
         *   });
         *   constructor(private s: DataPersistence<TodosState>, private backend: Backend) {}
         * }
         * ```
         */
        /**
         * \@whatItDoes Handles data fetching as part of router navigation.
         *
         * Data fetching implemented naively suffers from race conditions and poor error handling.
         *
         * `navigation` addresses these problems.
         *
         * It checks if an activated router state contains the passed in component type, and, if it does, runs the `run`
         * callback. It provides the activated snapshot associated with the component and the current state. And it only runs
         * the last request.
         *
         * ## Example:
         *
         * ```typescript
         * \@Injectable()
         * class TodoEffects {
         * \@Effect() loadTodo = this.s.navigation(TodoComponent, {
         *     run: (a, state) => {
         *       return this.backend.fetchTodo(a.params['id']).map(todo => ({
         *         type: 'TODO_LOADED',
         *         payload: todo
         *       }));
         *     },
         *     onError: (a, e: any) => {
         *       // we can log and error here and return null
         *       // we can also navigate back
         *       return null;
         *     }
         *   });
         *   constructor(private s: DataPersistence<TodosState>, private backend: Backend) {}
         * }
         * ```
         * @param {?} component
         * @param {?} opts
         * @return {?}
         */
        DataPersistence.prototype.navigation = /**
         * \@whatItDoes Handles data fetching as part of router navigation.
         *
         * Data fetching implemented naively suffers from race conditions and poor error handling.
         *
         * `navigation` addresses these problems.
         *
         * It checks if an activated router state contains the passed in component type, and, if it does, runs the `run`
         * callback. It provides the activated snapshot associated with the component and the current state. And it only runs
         * the last request.
         *
         * ## Example:
         *
         * ```typescript
         * \@Injectable()
         * class TodoEffects {
         * \@Effect() loadTodo = this.s.navigation(TodoComponent, {
         *     run: (a, state) => {
         *       return this.backend.fetchTodo(a.params['id']).map(todo => ({
         *         type: 'TODO_LOADED',
         *         payload: todo
         *       }));
         *     },
         *     onError: (a, e: any) => {
         *       // we can log and error here and return null
         *       // we can also navigate back
         *       return null;
         *     }
         *   });
         *   constructor(private s: DataPersistence<TodosState>, private backend: Backend) {}
         * }
         * ```
         * @param {?} component
         * @param {?} opts
         * @return {?}
         */
            function (component, opts) {
                return this.actions.pipe(operators.withLatestFrom(this.store), navigation(component, opts));
            };
        DataPersistence.decorators = [
            { type: core.Injectable }
        ];
        /** @nocollapse */
        DataPersistence.ctorParameters = function () {
            return [
                { type: store.Store },
                { type: effects.Actions }
            ];
        };
        return DataPersistence;
    }());
    /**
     * @param {?} component
     * @param {?} s
     * @return {?}
     */
    function findSnapshot(component, s) {
        var e_1, _a;
        if (s.routeConfig && s.routeConfig.component === component) {
            return s;
        }
        try {
            for (var _b = __values(s.children), _c = _b.next(); !_c.done; _c = _b.next()) {
                var c = _c.value;
                /** @type {?} */
                var ss = findSnapshot(component, c);
                if (ss) {
                    return ss;
                }
            }
        }
        catch (e_1_1) {
            e_1 = { error: e_1_1 };
        }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return))
                    _a.call(_b);
            }
            finally {
                if (e_1)
                    throw e_1.error;
            }
        }
        return null;
    }
    /**
     * @template O
     * @param {?} obj
     * @return {?}
     */
    function wrapIntoObservable(obj) {
        if (!!obj && obj instanceof rxjs.Observable) {
            return obj;
        }
        else if (!obj) {
            return rxjs.of();
        }
        else {
            return rxjs.of(( /** @type {?} */(obj)));
        }
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * \@whatItDoes Provides services for enterprise Angular applications.
     *
     * See {\@link DataPersistence} for more information.
     */
    var NxModule = /** @class */ (function () {
        function NxModule() {
        }
        /**
         * @return {?}
         */
        NxModule.forRoot = /**
         * @return {?}
         */
            function () {
                return { ngModule: NxModule, providers: [DataPersistence] };
            };
        NxModule.decorators = [
            { type: core.NgModule, args: [{},] }
        ];
        return NxModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */

    exports.DataPersistence = DataPersistence;
    exports.fetch = fetch;
    exports.navigation = navigation;
    exports.optimisticUpdate = optimisticUpdate;
    exports.pessimisticUpdate = pessimisticUpdate;
    exports.NxModule = NxModule;

    Object.defineProperty(exports, '__esModule', { value: true });

})));

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibnJ3bC1ueC51bWQuanMubWFwIiwic291cmNlcyI6WyJub2RlX21vZHVsZXMvdHNsaWIvdHNsaWIuZXM2LmpzIiwibmc6Ly9AbnJ3bC9ueC9zcmMvZGF0YS1wZXJzaXN0ZW5jZS50cyIsIm5nOi8vQG5yd2wvbngvc3JjL254Lm1vZHVsZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZVxyXG50aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZVxyXG5MaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG5cclxuVEhJUyBDT0RFIElTIFBST1ZJREVEIE9OIEFOICpBUyBJUyogQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG5LSU5ELCBFSVRIRVIgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgV0lUSE9VVCBMSU1JVEFUSU9OIEFOWSBJTVBMSUVEXHJcbldBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBUSVRMRSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UsXHJcbk1FUkNIQU5UQUJMSVRZIE9SIE5PTi1JTkZSSU5HRU1FTlQuXHJcblxyXG5TZWUgdGhlIEFwYWNoZSBWZXJzaW9uIDIuMCBMaWNlbnNlIGZvciBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnNcclxuYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG4vKiBnbG9iYWwgUmVmbGVjdCwgUHJvbWlzZSAqL1xyXG5cclxudmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbihkLCBiKSB7XHJcbiAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbn07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19leHRlbmRzKGQsIGIpIHtcclxuICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxufVxyXG5cclxuZXhwb3J0IHZhciBfX2Fzc2lnbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uIF9fYXNzaWduKHQpIHtcclxuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKSB0W3BdID0gc1twXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fcmVzdChzLCBlKSB7XHJcbiAgICB2YXIgdCA9IHt9O1xyXG4gICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXHJcbiAgICAgICAgdFtwXSA9IHNbcF07XHJcbiAgICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDApXHJcbiAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xyXG4gICAgcmV0dXJuIHQ7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2RlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcclxuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XHJcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19wYXJhbShwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHsgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19tZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSkge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXdhaXRlcih0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUocmVzdWx0LnZhbHVlKTsgfSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxyXG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcclxuICAgIH0pO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19nZW5lcmF0b3IodGhpc0FyZywgYm9keSkge1xyXG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcclxuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XHJcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xyXG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xyXG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XHJcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcclxuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xyXG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcclxuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XHJcbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2V4cG9ydFN0YXIobSwgZXhwb3J0cykge1xyXG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAoIWV4cG9ydHMuaGFzT3duUHJvcGVydHkocCkpIGV4cG9ydHNbcF0gPSBtW3BdO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX192YWx1ZXMobykge1xyXG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdLCBpID0gMDtcclxuICAgIGlmIChtKSByZXR1cm4gbS5jYWxsKG8pO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XHJcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19yZWFkKG8sIG4pIHtcclxuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcclxuICAgIGlmICghbSkgcmV0dXJuIG87XHJcbiAgICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cclxuICAgIGZpbmFsbHkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmaW5hbGx5IHsgaWYgKGUpIHRocm93IGUuZXJyb3I7IH1cclxuICAgIH1cclxuICAgIHJldHVybiBhcjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fc3ByZWFkKCkge1xyXG4gICAgZm9yICh2YXIgYXIgPSBbXSwgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgYXIgPSBhci5jb25jYXQoX19yZWFkKGFyZ3VtZW50c1tpXSkpO1xyXG4gICAgcmV0dXJuIGFyO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hd2FpdCh2KSB7XHJcbiAgICByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIF9fYXdhaXQgPyAodGhpcy52ID0gdiwgdGhpcykgOiBuZXcgX19hd2FpdCh2KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNHZW5lcmF0b3IodGhpc0FyZywgX2FyZ3VtZW50cywgZ2VuZXJhdG9yKSB7XHJcbiAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgdmFyIGcgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSksIGksIHEgPSBbXTtcclxuICAgIHJldHVybiBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyBpZiAoZ1tuXSkgaVtuXSA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoYSwgYikgeyBxLnB1c2goW24sIHYsIGEsIGJdKSA+IDEgfHwgcmVzdW1lKG4sIHYpOyB9KTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gcmVzdW1lKG4sIHYpIHsgdHJ5IHsgc3RlcChnW25dKHYpKTsgfSBjYXRjaCAoZSkgeyBzZXR0bGUocVswXVszXSwgZSk7IH0gfVxyXG4gICAgZnVuY3Rpb24gc3RlcChyKSB7IHIudmFsdWUgaW5zdGFuY2VvZiBfX2F3YWl0ID8gUHJvbWlzZS5yZXNvbHZlKHIudmFsdWUudikudGhlbihmdWxmaWxsLCByZWplY3QpIDogc2V0dGxlKHFbMF1bMl0sIHIpOyB9XHJcbiAgICBmdW5jdGlvbiBmdWxmaWxsKHZhbHVlKSB7IHJlc3VtZShcIm5leHRcIiwgdmFsdWUpOyB9XHJcbiAgICBmdW5jdGlvbiByZWplY3QodmFsdWUpIHsgcmVzdW1lKFwidGhyb3dcIiwgdmFsdWUpOyB9XHJcbiAgICBmdW5jdGlvbiBzZXR0bGUoZiwgdikgeyBpZiAoZih2KSwgcS5zaGlmdCgpLCBxLmxlbmd0aCkgcmVzdW1lKHFbMF1bMF0sIHFbMF1bMV0pOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jRGVsZWdhdG9yKG8pIHtcclxuICAgIHZhciBpLCBwO1xyXG4gICAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiLCBmdW5jdGlvbiAoZSkgeyB0aHJvdyBlOyB9KSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobiwgZikgeyBpW25dID0gb1tuXSA/IGZ1bmN0aW9uICh2KSB7IHJldHVybiAocCA9ICFwKSA/IHsgdmFsdWU6IF9fYXdhaXQob1tuXSh2KSksIGRvbmU6IG4gPT09IFwicmV0dXJuXCIgfSA6IGYgPyBmKHYpIDogdjsgfSA6IGY7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNWYWx1ZXMobykge1xyXG4gICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxuICAgIHZhciBtID0gb1tTeW1ib2wuYXN5bmNJdGVyYXRvcl0sIGk7XHJcbiAgICByZXR1cm4gbSA/IG0uY2FsbChvKSA6IChvID0gdHlwZW9mIF9fdmFsdWVzID09PSBcImZ1bmN0aW9uXCIgPyBfX3ZhbHVlcyhvKSA6IG9bU3ltYm9sLml0ZXJhdG9yXSgpLCBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaSk7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgaVtuXSA9IG9bbl0gJiYgZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHsgdiA9IG9bbl0odiksIHNldHRsZShyZXNvbHZlLCByZWplY3QsIHYuZG9uZSwgdi52YWx1ZSk7IH0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCBkLCB2KSB7IFByb21pc2UucmVzb2x2ZSh2KS50aGVuKGZ1bmN0aW9uKHYpIHsgcmVzb2x2ZSh7IHZhbHVlOiB2LCBkb25lOiBkIH0pOyB9LCByZWplY3QpOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX21ha2VUZW1wbGF0ZU9iamVjdChjb29rZWQsIHJhdykge1xyXG4gICAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29va2VkLCBcInJhd1wiLCB7IHZhbHVlOiByYXcgfSk7IH0gZWxzZSB7IGNvb2tlZC5yYXcgPSByYXc7IH1cclxuICAgIHJldHVybiBjb29rZWQ7XHJcbn07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19pbXBvcnRTdGFyKG1vZCkge1xyXG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcclxuICAgIHZhciByZXN1bHQgPSB7fTtcclxuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSByZXN1bHRba10gPSBtb2Rba107XHJcbiAgICByZXN1bHQuZGVmYXVsdCA9IG1vZDtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2ltcG9ydERlZmF1bHQobW9kKSB7XHJcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IGRlZmF1bHQ6IG1vZCB9O1xyXG59XHJcbiIsImltcG9ydCB7IEluamVjdGFibGUsIFR5cGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEFjdGl2YXRlZFJvdXRlU25hcHNob3QsIFJvdXRlclN0YXRlU25hcHNob3QgfSBmcm9tICdAYW5ndWxhci9yb3V0ZXInO1xuaW1wb3J0IHsgQWN0aW9ucywgb2ZUeXBlIH0gZnJvbSAnQG5ncngvZWZmZWN0cyc7XG5pbXBvcnQgeyBST1VURVJfTkFWSUdBVElPTiwgUm91dGVyTmF2aWdhdGlvbkFjdGlvbiB9IGZyb20gJ0BuZ3J4L3JvdXRlci1zdG9yZSc7XG5pbXBvcnQgeyBBY3Rpb24sIFN0b3JlIH0gZnJvbSAnQG5ncngvc3RvcmUnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSwgb2YgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7XG4gIGNhdGNoRXJyb3IsXG4gIGNvbmNhdE1hcCxcbiAgZmlsdGVyLFxuICBncm91cEJ5LFxuICBtYXAsXG4gIG1lcmdlTWFwLFxuICBzd2l0Y2hNYXAsXG4gIHdpdGhMYXRlc3RGcm9tXG59IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcblxuLyoqXG4gKiBTZWUge0BsaW5rIERhdGFQZXJzaXN0ZW5jZS5wZXNzaW1pc3RpY1VwZGF0ZX0gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUGVzc2ltaXN0aWNVcGRhdGVPcHRzPFQsIEE+IHtcbiAgcnVuKGE6IEEsIHN0YXRlPzogVCk6IE9ic2VydmFibGU8QWN0aW9uPiB8IEFjdGlvbiB8IHZvaWQ7XG4gIG9uRXJyb3IoYTogQSwgZTogYW55KTogT2JzZXJ2YWJsZTxhbnk+IHwgYW55O1xufVxuLyoqXG4gKiBTZWUge0BsaW5rIERhdGFQZXJzaXN0ZW5jZS5wZXNzaW1pc3RpY1VwZGF0ZX0gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgT3B0aW1pc3RpY1VwZGF0ZU9wdHM8VCwgQT4ge1xuICBydW4oYTogQSwgc3RhdGU/OiBUKTogT2JzZXJ2YWJsZTxBY3Rpb24+IHwgQWN0aW9uIHwgdm9pZDtcbiAgdW5kb0FjdGlvbihhOiBBLCBlOiBhbnkpOiBPYnNlcnZhYmxlPEFjdGlvbj4gfCBBY3Rpb247XG59XG5cbi8qKlxuICogU2VlIHtAbGluayBEYXRhUGVyc2lzdGVuY2UuZmV0Y2h9IGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIEZldGNoT3B0czxULCBBPiB7XG4gIGlkPyhhOiBBLCBzdGF0ZT86IFQpOiBhbnk7XG4gIHJ1bihhOiBBLCBzdGF0ZT86IFQpOiBPYnNlcnZhYmxlPEFjdGlvbj4gfCBBY3Rpb24gfCB2b2lkO1xuICBvbkVycm9yPyhhOiBBLCBlOiBhbnkpOiBPYnNlcnZhYmxlPGFueT4gfCBhbnk7XG59XG5cbi8qKlxuICogU2VlIHtAbGluayBEYXRhUGVyc2lzdGVuY2UubmF2aWdhdGlvbn0gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSGFuZGxlTmF2aWdhdGlvbk9wdHM8VD4ge1xuICBydW4oYTogQWN0aXZhdGVkUm91dGVTbmFwc2hvdCwgc3RhdGU/OiBUKTogT2JzZXJ2YWJsZTxBY3Rpb24+IHwgQWN0aW9uIHwgdm9pZDtcbiAgb25FcnJvcj8oYTogQWN0aXZhdGVkUm91dGVTbmFwc2hvdCwgZTogYW55KTogT2JzZXJ2YWJsZTxhbnk+IHwgYW55O1xufVxuXG5leHBvcnQgdHlwZSBBY3Rpb25PckFjdGlvbldpdGhTdGF0ZTxULCBBPiA9IEEgfCBbQSwgVF07XG5leHBvcnQgdHlwZSBBY3Rpb25TdGF0ZVN0cmVhbTxULCBBPiA9IE9ic2VydmFibGU8QWN0aW9uT3JBY3Rpb25XaXRoU3RhdGU8VCwgQT4+O1xuXG5leHBvcnQgZnVuY3Rpb24gcGVzc2ltaXN0aWNVcGRhdGU8VCwgQSBleHRlbmRzIEFjdGlvbj4oXG4gIG9wdHM6IFBlc3NpbWlzdGljVXBkYXRlT3B0czxULCBBPlxuKSB7XG4gIHJldHVybiAoc291cmNlOiBBY3Rpb25TdGF0ZVN0cmVhbTxULCBBPik6IE9ic2VydmFibGU8QWN0aW9uPiA9PiB7XG4gICAgcmV0dXJuIHNvdXJjZS5waXBlKFxuICAgICAgbWFwQWN0aW9uQW5kU3RhdGUoKSxcbiAgICAgIGNvbmNhdE1hcChydW5XaXRoRXJyb3JIYW5kbGluZyhvcHRzLnJ1biwgb3B0cy5vbkVycm9yKSlcbiAgICApO1xuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gb3B0aW1pc3RpY1VwZGF0ZTxULCBBIGV4dGVuZHMgQWN0aW9uPihcbiAgb3B0czogT3B0aW1pc3RpY1VwZGF0ZU9wdHM8VCwgQT5cbikge1xuICByZXR1cm4gKHNvdXJjZTogQWN0aW9uU3RhdGVTdHJlYW08VCwgQT4pOiBPYnNlcnZhYmxlPEFjdGlvbj4gPT4ge1xuICAgIHJldHVybiBzb3VyY2UucGlwZShcbiAgICAgIG1hcEFjdGlvbkFuZFN0YXRlKCksXG4gICAgICBjb25jYXRNYXAocnVuV2l0aEVycm9ySGFuZGxpbmcob3B0cy5ydW4sIG9wdHMudW5kb0FjdGlvbikpXG4gICAgKTtcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZldGNoPFQsIEEgZXh0ZW5kcyBBY3Rpb24+KG9wdHM6IEZldGNoT3B0czxULCBBPikge1xuICByZXR1cm4gKHNvdXJjZTogQWN0aW9uU3RhdGVTdHJlYW08VCwgQT4pOiBPYnNlcnZhYmxlPEFjdGlvbj4gPT4ge1xuICAgIGlmIChvcHRzLmlkKSB7XG4gICAgICBjb25zdCBncm91cGVkRmV0Y2hlcyA9IHNvdXJjZS5waXBlKFxuICAgICAgICBtYXBBY3Rpb25BbmRTdGF0ZSgpLFxuICAgICAgICBncm91cEJ5KChbYWN0aW9uLCBzdG9yZV0pID0+IHtcbiAgICAgICAgICByZXR1cm4gb3B0cy5pZChhY3Rpb24sIHN0b3JlKTtcbiAgICAgICAgfSlcbiAgICAgICk7XG5cbiAgICAgIHJldHVybiBncm91cGVkRmV0Y2hlcy5waXBlKFxuICAgICAgICBtZXJnZU1hcChwYWlycyA9PlxuICAgICAgICAgIHBhaXJzLnBpcGUoc3dpdGNoTWFwKHJ1bldpdGhFcnJvckhhbmRsaW5nKG9wdHMucnVuLCBvcHRzLm9uRXJyb3IpKSlcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc291cmNlLnBpcGUoXG4gICAgICBtYXBBY3Rpb25BbmRTdGF0ZSgpLFxuICAgICAgY29uY2F0TWFwKHJ1bldpdGhFcnJvckhhbmRsaW5nKG9wdHMucnVuLCBvcHRzLm9uRXJyb3IpKVxuICAgICk7XG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBuYXZpZ2F0aW9uPFQsIEEgZXh0ZW5kcyBBY3Rpb24+KFxuICBjb21wb25lbnQ6IFR5cGU8YW55PixcbiAgb3B0czogSGFuZGxlTmF2aWdhdGlvbk9wdHM8VD5cbikge1xuICByZXR1cm4gKHNvdXJjZTogQWN0aW9uU3RhdGVTdHJlYW08VCwgQT4pID0+IHtcbiAgICBjb25zdCBuYXYgPSBzb3VyY2UucGlwZShcbiAgICAgIG1hcEFjdGlvbkFuZFN0YXRlKCksXG4gICAgICBmaWx0ZXIoKFthY3Rpb24sIHN0YXRlXSkgPT4gaXNTdGF0ZVNuYXBzaG90KGFjdGlvbikpLFxuICAgICAgbWFwKChbYWN0aW9uLCBzdGF0ZV0pID0+IHtcbiAgICAgICAgaWYgKCFpc1N0YXRlU25hcHNob3QoYWN0aW9uKSkge1xuICAgICAgICAgIC8vIEJlY2F1c2Ugb2YgdGhlIGFib3ZlIGZpbHRlciB3ZSdsbCBuZXZlciBnZXQgaGVyZSxcbiAgICAgICAgICAvLyBidXQgdGhpcyBwcm9wZXJseSB0eXBlIG5hcnJvd3MgYGFjdGlvbmBcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgIGZpbmRTbmFwc2hvdChjb21wb25lbnQsIGFjdGlvbi5wYXlsb2FkLnJvdXRlclN0YXRlLnJvb3QpLFxuICAgICAgICAgIHN0YXRlXG4gICAgICAgIF0gYXMgW0FjdGl2YXRlZFJvdXRlU25hcHNob3QsIFRdO1xuICAgICAgfSksXG4gICAgICBmaWx0ZXIoKFtzbmFwc2hvdCwgc3RhdGVdKSA9PiAhIXNuYXBzaG90KVxuICAgICk7XG5cbiAgICByZXR1cm4gbmF2LnBpcGUoc3dpdGNoTWFwKHJ1bldpdGhFcnJvckhhbmRsaW5nKG9wdHMucnVuLCBvcHRzLm9uRXJyb3IpKSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGlzU3RhdGVTbmFwc2hvdChcbiAgYWN0aW9uOiBhbnlcbik6IGFjdGlvbiBpcyBSb3V0ZXJOYXZpZ2F0aW9uQWN0aW9uPFJvdXRlclN0YXRlU25hcHNob3Q+IHtcbiAgcmV0dXJuIGFjdGlvbi50eXBlID09PSBST1VURVJfTkFWSUdBVElPTjtcbn1cblxuZnVuY3Rpb24gcnVuV2l0aEVycm9ySGFuZGxpbmc8VCwgQSwgUj4oXG4gIHJ1bjogKGE6IEEsIHN0YXRlPzogVCkgPT4gT2JzZXJ2YWJsZTxSPiB8IFIgfCB2b2lkLFxuICBvbkVycm9yOiBhbnlcbikge1xuICByZXR1cm4gKFthY3Rpb24sIHN0YXRlXTogW0EsIFRdKTogT2JzZXJ2YWJsZTxSPiA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHIgPSB3cmFwSW50b09ic2VydmFibGUocnVuKGFjdGlvbiwgc3RhdGUpKTtcbiAgICAgIHJldHVybiByLnBpcGUoY2F0Y2hFcnJvcihlID0+IHdyYXBJbnRvT2JzZXJ2YWJsZShvbkVycm9yKGFjdGlvbiwgZSkpKSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIHdyYXBJbnRvT2JzZXJ2YWJsZShvbkVycm9yKGFjdGlvbiwgZSkpO1xuICAgIH1cbiAgfTtcbn1cblxuLyoqXG4gKiBAd2hhdEl0RG9lcyBtYXBzIE9ic2VydmFibGU8QWN0aW9uIHwgW0FjdGlvbiwgU3RhdGVdPiB0b1xuICogT2JzZXJ2YWJsZTxbQWN0aW9uLCBTdGF0ZV0+XG4gKi9cbmZ1bmN0aW9uIG1hcEFjdGlvbkFuZFN0YXRlPFQsIEE+KCkge1xuICByZXR1cm4gKHNvdXJjZTogT2JzZXJ2YWJsZTxBY3Rpb25PckFjdGlvbldpdGhTdGF0ZTxULCBBPj4pID0+IHtcbiAgICByZXR1cm4gc291cmNlLnBpcGUoXG4gICAgICBtYXAodmFsdWUgPT4ge1xuICAgICAgICBjb25zdCBbYWN0aW9uLCBzdG9yZV0gPSBub3JtYWxpemVBY3Rpb25BbmRTdGF0ZSh2YWx1ZSk7XG4gICAgICAgIHJldHVybiBbYWN0aW9uLCBzdG9yZV0gYXMgW0EsIFRdO1xuICAgICAgfSlcbiAgICApO1xuICB9O1xufVxuXG4vKipcbiAqIEB3aGF0SXREb2VzIE5vcm1hbGl6ZXMgZWl0aGVyIGEgYmFyZSBhY3Rpb24gb3IgYW4gYXJyYXkgb2YgYWN0aW9uIGFuZCBzdGF0ZVxuICogaW50byBhbiBhcnJheSBvZiBhY3Rpb24gYW5kIHN0YXRlIChvciB1bmRlZmluZWQpXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZUFjdGlvbkFuZFN0YXRlPFQsIEE+KFxuICBhcmdzOiBBY3Rpb25PckFjdGlvbldpdGhTdGF0ZTxULCBBPlxuKTogW0EsIFRdIHtcbiAgbGV0IGFjdGlvbjogQSwgc3RhdGU6IFQ7XG5cbiAgaWYgKGFyZ3MgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgIFthY3Rpb24sIHN0YXRlXSA9IGFyZ3M7XG4gIH0gZWxzZSB7XG4gICAgYWN0aW9uID0gYXJncztcbiAgfVxuXG4gIHJldHVybiBbYWN0aW9uLCBzdGF0ZV07XG59XG5cbi8qKlxuICogQHdoYXRJdERvZXMgUHJvdmlkZXMgY29udmVuaWVuY2UgbWV0aG9kcyBmb3IgaW1wbGVtZW50aW5nIGNvbW1vbiBvcGVyYXRpb25zIG9mIHBlcnNpc3RpbmcgZGF0YS5cbiAqL1xuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIERhdGFQZXJzaXN0ZW5jZTxUPiB7XG4gIGNvbnN0cnVjdG9yKHB1YmxpYyBzdG9yZTogU3RvcmU8VD4sIHB1YmxpYyBhY3Rpb25zOiBBY3Rpb25zKSB7fVxuXG4gIC8qKlxuICAgKlxuICAgKiBAd2hhdEl0RG9lcyBIYW5kbGVzIHBlc3NpbWlzdGljIHVwZGF0ZXMgKHVwZGF0aW5nIHRoZSBzZXJ2ZXIgZmlyc3QpLlxuICAgKlxuICAgKiBVcGRhdGUgdGhlIHNlcnZlciBpbXBsZW1lbnRlZCBuYWl2ZWx5IHN1ZmZlcnMgZnJvbSByYWNlIGNvbmRpdGlvbnMgYW5kIHBvb3IgZXJyb3IgaGFuZGxpbmcuXG4gICAqXG4gICAqIGBwZXNzaW1pc3RpY1VwZGF0ZWAgYWRkcmVzc2VzIHRoZXNlIHByb2JsZW1zLS1pdCBydW5zIGFsbCBmZXRjaGVzIGluIG9yZGVyLCB3aGljaCByZW1vdmVzIHJhY2UgY29uZGl0aW9uc1xuICAgKiBhbmQgZm9yY2VzIHRoZSBkZXZlbG9wZXIgdG8gaGFuZGxlIGVycm9ycy5cbiAgICpcbiAgICogIyMgRXhhbXBsZTpcbiAgICpcbiAgICogYGBgdHlwZXNjcmlwdFxuICAgKiBASW5qZWN0YWJsZSgpXG4gICAqIGNsYXNzIFRvZG9FZmZlY3RzIHtcbiAgICogICBARWZmZWN0KCkgdXBkYXRlVG9kbyA9IHRoaXMucy5wZXNzaW1pc3RpY1VwZGF0ZTxVcGRhdGVUb2RvPignVVBEQVRFX1RPRE8nLCB7XG4gICAqICAgICAvLyBwcm92aWRlcyBhbiBhY3Rpb24gYW5kIHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBzdG9yZVxuICAgKiAgICAgcnVuKGEsIHN0YXRlKSB7XG4gICAqICAgICAgIC8vIHVwZGF0ZSB0aGUgYmFja2VuZCBmaXJzdCwgYW5kIHRoZW4gZGlzcGF0Y2ggYW4gYWN0aW9uIHRoYXQgd2lsbFxuICAgKiAgICAgICAvLyB1cGRhdGUgdGhlIGNsaWVudCBzaWRlXG4gICAqICAgICAgIHJldHVybiB0aGlzLmJhY2tlbmQoc3RhdGUudXNlciwgYS5wYXlsb2FkKS5tYXAodXBkYXRlZCA9PiAoe1xuICAgKiAgICAgICAgIHR5cGU6ICdUT0RPX1VQREFURUQnLFxuICAgKiAgICAgICAgIHBheWxvYWQ6IHVwZGF0ZWRcbiAgICogICAgICAgfSkpO1xuICAgKiAgICAgfSxcbiAgICpcbiAgICogICAgIG9uRXJyb3IoYSwgZTogYW55KSB7XG4gICAqICAgICAgIC8vIHdlIGRvbid0IG5lZWQgdG8gdW5kbyB0aGUgY2hhbmdlcyBvbiB0aGUgY2xpZW50IHNpZGUuXG4gICAqICAgICAgIC8vIHdlIGNhbiBkaXNwYXRjaCBhbiBlcnJvciwgb3Igc2ltcGx5IGxvZyB0aGUgZXJyb3IgaGVyZSBhbmQgcmV0dXJuIGBudWxsYFxuICAgKiAgICAgICByZXR1cm4gbnVsbDtcbiAgICogICAgIH1cbiAgICogICB9KTtcbiAgICpcbiAgICogICBjb25zdHJ1Y3Rvcihwcml2YXRlIHM6IERhdGFQZXJzaXN0ZW5jZTxUb2Rvc1N0YXRlPiwgcHJpdmF0ZSBiYWNrZW5kOiBCYWNrZW5kKSB7fVxuICAgKiB9XG4gICAqIGBgYFxuICAgKlxuICAgKiBOb3RlIHRoYXQgaWYgeW91IGRvbid0IHJldHVybiBhIG5ldyBhY3Rpb24gZnJvbSB0aGUgcnVuIGNhbGxiYWNrLCB5b3UgbXVzdCBzZXQgdGhlIGRpc3BhdGNoIHByb3BlcnR5XG4gICAqIG9mIHRoZSBlZmZlY3QgdG8gZmFsc2UsIGxpa2UgdGhpczpcbiAgICpcbiAgICogYGBgXG4gICAqIGNsYXNzIFRvZG9FZmZlY3RzIHtcbiAgICogICBARWZmZWN0KHtkaXNwYXRjaDogZmFsc2V9KVxuICAgKiAgIHVwZGF0ZVRvZG87IC8vLi4uXG4gICAqIH1cbiAgICogYGBgXG4gICAqL1xuICBwZXNzaW1pc3RpY1VwZGF0ZTxBIGV4dGVuZHMgQWN0aW9uID0gQWN0aW9uPihcbiAgICBhY3Rpb25UeXBlOiBzdHJpbmcsXG4gICAgb3B0czogUGVzc2ltaXN0aWNVcGRhdGVPcHRzPFQsIEE+XG4gICk6IE9ic2VydmFibGU8YW55PiB7XG4gICAgcmV0dXJuIHRoaXMuYWN0aW9ucy5waXBlKFxuICAgICAgb2ZUeXBlPEE+KGFjdGlvblR5cGUpLFxuICAgICAgd2l0aExhdGVzdEZyb20odGhpcy5zdG9yZSksXG4gICAgICBwZXNzaW1pc3RpY1VwZGF0ZShvcHRzKVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQHdoYXRJdERvZXMgSGFuZGxlcyBvcHRpbWlzdGljIHVwZGF0ZXMgKHVwZGF0aW5nIHRoZSBjbGllbnQgZmlyc3QpLlxuICAgKlxuICAgKiBgb3B0aW1pc3RpY1VwZGF0ZWAgYWRkcmVzc2VzIHRoZXNlIHByb2JsZW1zLS1pdCBydW5zIGFsbCBmZXRjaGVzIGluIG9yZGVyLCB3aGljaCByZW1vdmVzIHJhY2UgY29uZGl0aW9uc1xuICAgKiBhbmQgZm9yY2VzIHRoZSBkZXZlbG9wZXIgdG8gaGFuZGxlIGVycm9ycy5cbiAgICpcbiAgICogYG9wdGltaXN0aWNVcGRhdGVgIGlzIGRpZmZlcmVudCBmcm9tIGBwZXNzaW1pc3RpY1VwZGF0ZWAuIEluIGNhc2Ugb2YgYSBmYWlsdXJlLCB3aGVuIHVzaW5nIGBvcHRpbWlzdGljVXBkYXRlYCxcbiAgICogdGhlIGRldmVsb3BlciBhbHJlYWR5IHVwZGF0ZWQgdGhlIHN0YXRlIGxvY2FsbHksIHNvIHRoZSBkZXZlbG9wZXIgbXVzdCBwcm92aWRlIGFuIHVuZG8gYWN0aW9uLlxuICAgKlxuICAgKiBUaGUgZXJyb3IgaGFuZGxpbmcgbXVzdCBiZSBkb25lIGluIHRoZSBjYWxsYmFjaywgb3IgYnkgbWVhbnMgb2YgdGhlIHVuZG8gYWN0aW9uLlxuICAgKlxuICAgKiAjIyBFeGFtcGxlOlxuICAgKlxuICAgKiBgYGB0eXBlc2NyaXB0XG4gICAqIEBJbmplY3RhYmxlKClcbiAgICogY2xhc3MgVG9kb0VmZmVjdHMge1xuICAgKiAgIEBFZmZlY3QoKSB1cGRhdGVUb2RvID0gdGhpcy5zLm9wdGltaXN0aWNVcGRhdGU8VXBkYXRlVG9kbz4oJ1VQREFURV9UT0RPJywge1xuICAgKiAgICAgLy8gcHJvdmlkZXMgYW4gYWN0aW9uIGFuZCB0aGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgc3RvcmVcbiAgICogICAgIHJ1bjogKGEsIHN0YXRlKSA9PiB7XG4gICAqICAgICAgIHJldHVybiB0aGlzLmJhY2tlbmQoc3RhdGUudXNlciwgYS5wYXlsb2FkKTtcbiAgICogICAgIH0sXG4gICAqXG4gICAqICAgICB1bmRvQWN0aW9uOiAoYSwgZTogYW55KSA9PiB7XG4gICAqICAgICAgIC8vIGRpc3BhdGNoIGFuIHVuZG8gYWN0aW9uIHRvIHVuZG8gdGhlIGNoYW5nZXMgaW4gdGhlIGNsaWVudCBzdGF0ZVxuICAgKiAgICAgICByZXR1cm4gKHtcbiAgICogICAgICAgICB0eXBlOiAnVU5ET19VUERBVEVfVE9ETycsXG4gICAqICAgICAgICAgcGF5bG9hZDogYVxuICAgKiAgICAgICB9KTtcbiAgICogICAgIH1cbiAgICogICB9KTtcbiAgICpcbiAgICogICBjb25zdHJ1Y3Rvcihwcml2YXRlIHM6IERhdGFQZXJzaXN0ZW5jZTxUb2Rvc1N0YXRlPiwgcHJpdmF0ZSBiYWNrZW5kOiBCYWNrZW5kKSB7fVxuICAgKiB9XG4gICAqIGBgYFxuICAgKlxuICAgKiBOb3RlIHRoYXQgaWYgeW91IGRvbid0IHJldHVybiBhIG5ldyBhY3Rpb24gZnJvbSB0aGUgcnVuIGNhbGxiYWNrLCB5b3UgbXVzdCBzZXQgdGhlIGRpc3BhdGNoIHByb3BlcnR5XG4gICAqIG9mIHRoZSBlZmZlY3QgdG8gZmFsc2UsIGxpa2UgdGhpczpcbiAgICpcbiAgICogYGBgXG4gICAqIGNsYXNzIFRvZG9FZmZlY3RzIHtcbiAgICogICBARWZmZWN0KHtkaXNwYXRjaDogZmFsc2V9KVxuICAgKiAgIHVwZGF0ZVRvZG87IC8vLi4uXG4gICAqIH1cbiAgICogYGBgXG4gICAqL1xuICBvcHRpbWlzdGljVXBkYXRlPEEgZXh0ZW5kcyBBY3Rpb24gPSBBY3Rpb24+KFxuICAgIGFjdGlvblR5cGU6IHN0cmluZyxcbiAgICBvcHRzOiBPcHRpbWlzdGljVXBkYXRlT3B0czxULCBBPlxuICApOiBPYnNlcnZhYmxlPGFueT4ge1xuICAgIHJldHVybiB0aGlzLmFjdGlvbnMucGlwZShcbiAgICAgIG9mVHlwZTxBPihhY3Rpb25UeXBlKSxcbiAgICAgIHdpdGhMYXRlc3RGcm9tKHRoaXMuc3RvcmUpLFxuICAgICAgb3B0aW1pc3RpY1VwZGF0ZShvcHRzKVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQHdoYXRJdERvZXMgSGFuZGxlcyBkYXRhIGZldGNoaW5nLlxuICAgKlxuICAgKiBEYXRhIGZldGNoaW5nIGltcGxlbWVudGVkIG5haXZlbHkgc3VmZmVycyBmcm9tIHJhY2UgY29uZGl0aW9ucyBhbmQgcG9vciBlcnJvciBoYW5kbGluZy5cbiAgICpcbiAgICogYGZldGNoYCBhZGRyZXNzZXMgdGhlc2UgcHJvYmxlbXMtLWl0IHJ1bnMgYWxsIGZldGNoZXMgaW4gb3JkZXIsIHdoaWNoIHJlbW92ZXMgcmFjZSBjb25kaXRpb25zXG4gICAqIGFuZCBmb3JjZXMgdGhlIGRldmVsb3BlciB0byBoYW5kbGUgZXJyb3JzLlxuICAgKlxuICAgKiAjIyBFeGFtcGxlOlxuICAgKlxuICAgKiBgYGB0eXBlc2NyaXB0XG4gICAqIEBJbmplY3RhYmxlKClcbiAgICogY2xhc3MgVG9kb0VmZmVjdHMge1xuICAgKiAgIEBFZmZlY3QoKSBsb2FkVG9kb3MgPSB0aGlzLnMuZmV0Y2g8R2V0VG9kb3M+KCdHRVRfVE9ET1MnLCB7XG4gICAqICAgICAvLyBwcm92aWRlcyBhbiBhY3Rpb24gYW5kIHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBzdG9yZVxuICAgKiAgICAgcnVuOiAoYSwgc3RhdGUpID0+IHtcbiAgICogICAgICAgcmV0dXJuIHRoaXMuYmFja2VuZChzdGF0ZS51c2VyLCBhLnBheWxvYWQpLm1hcChyID0+ICh7XG4gICAqICAgICAgICAgdHlwZTogJ1RPRE9TJyxcbiAgICogICAgICAgICBwYXlsb2FkOiByXG4gICAqICAgICAgIH0pO1xuICAgKiAgICAgfSxcbiAgICpcbiAgICogICAgIG9uRXJyb3I6IChhLCBlOiBhbnkpID0+IHtcbiAgICogICAgICAgLy8gZGlzcGF0Y2ggYW4gdW5kbyBhY3Rpb24gdG8gdW5kbyB0aGUgY2hhbmdlcyBpbiB0aGUgY2xpZW50IHN0YXRlXG4gICAqICAgICB9XG4gICAqICAgfSk7XG4gICAqXG4gICAqICAgY29uc3RydWN0b3IocHJpdmF0ZSBzOiBEYXRhUGVyc2lzdGVuY2U8VG9kb3NTdGF0ZT4sIHByaXZhdGUgYmFja2VuZDogQmFja2VuZCkge31cbiAgICogfVxuICAgKiBgYGBcbiAgICpcbiAgICogVGhpcyBpcyBjb3JyZWN0LCBidXQgYmVjYXVzZSBpdCBzZXQgdGhlIGNvbmN1cnJlbmN5IHRvIDEsIGl0IG1heSBub3QgYmUgcGVyZm9ybWFudC5cbiAgICpcbiAgICogVG8gZml4IHRoYXQsIHlvdSBjYW4gcHJvdmlkZSB0aGUgYGlkYCBmdW5jdGlvbiwgbGlrZSB0aGlzOlxuICAgKlxuICAgKiBgYGB0eXBlc2NyaXB0XG4gICAqIEBJbmplY3RhYmxlKClcbiAgICogY2xhc3MgVG9kb0VmZmVjdHMge1xuICAgKiAgIEBFZmZlY3QoKSBsb2FkVG9kbyA9IHRoaXMucy5mZXRjaDxHZXRUb2RvPignR0VUX1RPRE8nLCB7XG4gICAqICAgICBpZDogKGEsIHN0YXRlKSA9PiB7XG4gICAqICAgICAgIHJldHVybiBhLnBheWxvYWQuaWQ7XG4gICAqICAgICB9XG4gICAqXG4gICAqICAgICAvLyBwcm92aWRlcyBhbiBhY3Rpb24gYW5kIHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBzdG9yZVxuICAgKiAgICAgcnVuOiAoYSwgc3RhdGUpID0+IHtcbiAgICogICAgICAgcmV0dXJuIHRoaXMuYmFja2VuZChzdGF0ZS51c2VyLCBhLnBheWxvYWQpLm1hcChyID0+ICh7XG4gICAqICAgICAgICAgdHlwZTogJ1RPRE8nLFxuICAgKiAgICAgICAgIHBheWxvYWQ6IHJcbiAgICogICAgICAgfSk7XG4gICAqICAgICB9LFxuICAgKlxuICAgKiAgICAgb25FcnJvcjogKGEsIGU6IGFueSkgPT4ge1xuICAgKiAgICAgICAvLyBkaXNwYXRjaCBhbiB1bmRvIGFjdGlvbiB0byB1bmRvIHRoZSBjaGFuZ2VzIGluIHRoZSBjbGllbnQgc3RhdGVcbiAgICogICAgICAgcmV0dXJuIG51bGw7XG4gICAqICAgICB9XG4gICAqICAgfSk7XG4gICAqXG4gICAqICAgY29uc3RydWN0b3IocHJpdmF0ZSBzOiBEYXRhUGVyc2lzdGVuY2U8VG9kb3NTdGF0ZT4sIHByaXZhdGUgYmFja2VuZDogQmFja2VuZCkge31cbiAgICogfVxuICAgKiBgYGBcbiAgICpcbiAgICogV2l0aCB0aGlzIHNldHVwLCB0aGUgcmVxdWVzdHMgZm9yIFRvZG8gMSB3aWxsIHJ1biBjb25jdXJyZW50bHkgd2l0aCB0aGUgcmVxdWVzdHMgZm9yIFRvZG8gMi5cbiAgICpcbiAgICogSW4gYWRkaXRpb24sIGlmIERhdGFQZXJzaXN0ZW5jZSBub3RpY2VzIHRoYXQgdGhlcmUgYXJlIG11bHRpcGxlIHJlcXVlc3RzIGZvciBUb2RvIDEgc2NoZWR1bGVkLFxuICAgKiBpdCB3aWxsIG9ubHkgcnVuIHRoZSBsYXN0IG9uZS5cbiAgICovXG4gIGZldGNoPEEgZXh0ZW5kcyBBY3Rpb24gPSBBY3Rpb24+KFxuICAgIGFjdGlvblR5cGU6IHN0cmluZyxcbiAgICBvcHRzOiBGZXRjaE9wdHM8VCwgQT5cbiAgKTogT2JzZXJ2YWJsZTxhbnk+IHtcbiAgICByZXR1cm4gdGhpcy5hY3Rpb25zLnBpcGUoXG4gICAgICBvZlR5cGU8QT4oYWN0aW9uVHlwZSksXG4gICAgICB3aXRoTGF0ZXN0RnJvbSh0aGlzLnN0b3JlKSxcbiAgICAgIGZldGNoKG9wdHMpXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAd2hhdEl0RG9lcyBIYW5kbGVzIGRhdGEgZmV0Y2hpbmcgYXMgcGFydCBvZiByb3V0ZXIgbmF2aWdhdGlvbi5cbiAgICpcbiAgICogRGF0YSBmZXRjaGluZyBpbXBsZW1lbnRlZCBuYWl2ZWx5IHN1ZmZlcnMgZnJvbSByYWNlIGNvbmRpdGlvbnMgYW5kIHBvb3IgZXJyb3IgaGFuZGxpbmcuXG4gICAqXG4gICAqIGBuYXZpZ2F0aW9uYCBhZGRyZXNzZXMgdGhlc2UgcHJvYmxlbXMuXG4gICAqXG4gICAqIEl0IGNoZWNrcyBpZiBhbiBhY3RpdmF0ZWQgcm91dGVyIHN0YXRlIGNvbnRhaW5zIHRoZSBwYXNzZWQgaW4gY29tcG9uZW50IHR5cGUsIGFuZCwgaWYgaXQgZG9lcywgcnVucyB0aGUgYHJ1bmBcbiAgICogY2FsbGJhY2suIEl0IHByb3ZpZGVzIHRoZSBhY3RpdmF0ZWQgc25hcHNob3QgYXNzb2NpYXRlZCB3aXRoIHRoZSBjb21wb25lbnQgYW5kIHRoZSBjdXJyZW50IHN0YXRlLiBBbmQgaXQgb25seSBydW5zXG4gICAqIHRoZSBsYXN0IHJlcXVlc3QuXG4gICAqXG4gICAqICMjIEV4YW1wbGU6XG4gICAqXG4gICAqIGBgYHR5cGVzY3JpcHRcbiAgICogQEluamVjdGFibGUoKVxuICAgKiBjbGFzcyBUb2RvRWZmZWN0cyB7XG4gICAqICAgQEVmZmVjdCgpIGxvYWRUb2RvID0gdGhpcy5zLm5hdmlnYXRpb24oVG9kb0NvbXBvbmVudCwge1xuICAgKiAgICAgcnVuOiAoYSwgc3RhdGUpID0+IHtcbiAgICogICAgICAgcmV0dXJuIHRoaXMuYmFja2VuZC5mZXRjaFRvZG8oYS5wYXJhbXNbJ2lkJ10pLm1hcCh0b2RvID0+ICh7XG4gICAqICAgICAgICAgdHlwZTogJ1RPRE9fTE9BREVEJyxcbiAgICogICAgICAgICBwYXlsb2FkOiB0b2RvXG4gICAqICAgICAgIH0pKTtcbiAgICogICAgIH0sXG4gICAqICAgICBvbkVycm9yOiAoYSwgZTogYW55KSA9PiB7XG4gICAqICAgICAgIC8vIHdlIGNhbiBsb2cgYW5kIGVycm9yIGhlcmUgYW5kIHJldHVybiBudWxsXG4gICAqICAgICAgIC8vIHdlIGNhbiBhbHNvIG5hdmlnYXRlIGJhY2tcbiAgICogICAgICAgcmV0dXJuIG51bGw7XG4gICAqICAgICB9XG4gICAqICAgfSk7XG4gICAqICAgY29uc3RydWN0b3IocHJpdmF0ZSBzOiBEYXRhUGVyc2lzdGVuY2U8VG9kb3NTdGF0ZT4sIHByaXZhdGUgYmFja2VuZDogQmFja2VuZCkge31cbiAgICogfVxuICAgKiBgYGBcbiAgICovXG4gIG5hdmlnYXRpb24oXG4gICAgY29tcG9uZW50OiBUeXBlPGFueT4sXG4gICAgb3B0czogSGFuZGxlTmF2aWdhdGlvbk9wdHM8VD5cbiAgKTogT2JzZXJ2YWJsZTxhbnk+IHtcbiAgICByZXR1cm4gdGhpcy5hY3Rpb25zLnBpcGUoXG4gICAgICB3aXRoTGF0ZXN0RnJvbSh0aGlzLnN0b3JlKSxcbiAgICAgIG5hdmlnYXRpb24oY29tcG9uZW50LCBvcHRzKVxuICAgICk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluZFNuYXBzaG90KFxuICBjb21wb25lbnQ6IFR5cGU8YW55PixcbiAgczogQWN0aXZhdGVkUm91dGVTbmFwc2hvdFxuKTogQWN0aXZhdGVkUm91dGVTbmFwc2hvdCB7XG4gIGlmIChzLnJvdXRlQ29uZmlnICYmIHMucm91dGVDb25maWcuY29tcG9uZW50ID09PSBjb21wb25lbnQpIHtcbiAgICByZXR1cm4gcztcbiAgfVxuICBmb3IgKGNvbnN0IGMgb2Ygcy5jaGlsZHJlbikge1xuICAgIGNvbnN0IHNzID0gZmluZFNuYXBzaG90KGNvbXBvbmVudCwgYyk7XG4gICAgaWYgKHNzKSB7XG4gICAgICByZXR1cm4gc3M7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiB3cmFwSW50b09ic2VydmFibGU8Tz4ob2JqOiBPYnNlcnZhYmxlPE8+IHwgTyB8IHZvaWQpOiBPYnNlcnZhYmxlPE8+IHtcbiAgaWYgKCEhb2JqICYmIG9iaiBpbnN0YW5jZW9mIE9ic2VydmFibGUpIHtcbiAgICByZXR1cm4gb2JqO1xuICB9IGVsc2UgaWYgKCFvYmopIHtcbiAgICByZXR1cm4gb2YoKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gb2Yob2JqIGFzIE8pO1xuICB9XG59XG4iLCJpbXBvcnQgeyBNb2R1bGVXaXRoUHJvdmlkZXJzLCBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgRGF0YVBlcnNpc3RlbmNlIH0gZnJvbSAnLi9kYXRhLXBlcnNpc3RlbmNlJztcblxuLyoqXG4gKiBAd2hhdEl0RG9lcyBQcm92aWRlcyBzZXJ2aWNlcyBmb3IgZW50ZXJwcmlzZSBBbmd1bGFyIGFwcGxpY2F0aW9ucy5cbiAqXG4gKiBTZWUge0BsaW5rIERhdGFQZXJzaXN0ZW5jZX0gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gKi9cbkBOZ01vZHVsZSh7fSlcbmV4cG9ydCBjbGFzcyBOeE1vZHVsZSB7XG4gIHN0YXRpYyBmb3JSb290KCk6IE1vZHVsZVdpdGhQcm92aWRlcnMge1xuICAgIHJldHVybiB7IG5nTW9kdWxlOiBOeE1vZHVsZSwgcHJvdmlkZXJzOiBbRGF0YVBlcnNpc3RlbmNlXSB9O1xuICB9XG59XG4iXSwibmFtZXMiOlsiY29uY2F0TWFwIiwiZ3JvdXBCeSIsInN0b3JlIiwibWVyZ2VNYXAiLCJzd2l0Y2hNYXAiLCJmaWx0ZXIiLCJtYXAiLCJST1VURVJfTkFWSUdBVElPTiIsImNhdGNoRXJyb3IiLCJvZlR5cGUiLCJ3aXRoTGF0ZXN0RnJvbSIsIkluamVjdGFibGUiLCJTdG9yZSIsIkFjdGlvbnMiLCJ0c2xpYl8xLl9fdmFsdWVzIiwiT2JzZXJ2YWJsZSIsIm9mIiwiTmdNb2R1bGUiXSwibWFwcGluZ3MiOiI7Ozs7OztJQUFBOzs7Ozs7Ozs7Ozs7OztBQWNBLGFBNEZnQixRQUFRLENBQUMsQ0FBQztRQUN0QixJQUFJLENBQUMsR0FBRyxPQUFPLE1BQU0sS0FBSyxVQUFVLElBQUksQ0FBQyxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQ2xFLElBQUksQ0FBQztZQUFFLE9BQU8sQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUN4QixPQUFPO1lBQ0gsSUFBSSxFQUFFO2dCQUNGLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsTUFBTTtvQkFBRSxDQUFDLEdBQUcsS0FBSyxDQUFDLENBQUM7Z0JBQ25DLE9BQU8sRUFBRSxLQUFLLEVBQUUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLElBQUksRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDO2FBQzNDO1NBQ0osQ0FBQztJQUNOLENBQUM7QUFFRCxhQUFnQixNQUFNLENBQUMsQ0FBQyxFQUFFLENBQUM7UUFDdkIsSUFBSSxDQUFDLEdBQUcsT0FBTyxNQUFNLEtBQUssVUFBVSxJQUFJLENBQUMsQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLENBQUM7UUFDM0QsSUFBSSxDQUFDLENBQUM7WUFBRSxPQUFPLENBQUMsQ0FBQztRQUNqQixJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFLEdBQUcsRUFBRSxF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