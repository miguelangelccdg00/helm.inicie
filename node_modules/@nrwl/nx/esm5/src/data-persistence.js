/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { Injectable } from '@angular/core';
import { Actions, ofType } from '@ngrx/effects';
import { ROUTER_NAVIGATION } from '@ngrx/router-store';
import { Store } from '@ngrx/store';
import { Observable, of } from 'rxjs';
import { catchError, concatMap, filter, groupBy, map, mergeMap, switchMap, withLatestFrom } from 'rxjs/operators';
/**
 * See {\@link DataPersistence.pessimisticUpdate} for more information.
 * @record
 * @template T, A
 */
export function PessimisticUpdateOpts() { }
if (false) {
    /**
     * @param {?} a
     * @param {?=} state
     * @return {?}
     */
    PessimisticUpdateOpts.prototype.run = function (a, state) { };
    /**
     * @param {?} a
     * @param {?} e
     * @return {?}
     */
    PessimisticUpdateOpts.prototype.onError = function (a, e) { };
}
/**
 * See {\@link DataPersistence.pessimisticUpdate} for more information.
 * @record
 * @template T, A
 */
export function OptimisticUpdateOpts() { }
if (false) {
    /**
     * @param {?} a
     * @param {?=} state
     * @return {?}
     */
    OptimisticUpdateOpts.prototype.run = function (a, state) { };
    /**
     * @param {?} a
     * @param {?} e
     * @return {?}
     */
    OptimisticUpdateOpts.prototype.undoAction = function (a, e) { };
}
/**
 * See {\@link DataPersistence.fetch} for more information.
 * @record
 * @template T, A
 */
export function FetchOpts() { }
if (false) {
    /**
     * @param {?} a
     * @param {?=} state
     * @return {?}
     */
    FetchOpts.prototype.id = function (a, state) { };
    /**
     * @param {?} a
     * @param {?=} state
     * @return {?}
     */
    FetchOpts.prototype.run = function (a, state) { };
    /**
     * @param {?} a
     * @param {?} e
     * @return {?}
     */
    FetchOpts.prototype.onError = function (a, e) { };
}
/**
 * See {\@link DataPersistence.navigation} for more information.
 * @record
 * @template T
 */
export function HandleNavigationOpts() { }
if (false) {
    /**
     * @param {?} a
     * @param {?=} state
     * @return {?}
     */
    HandleNavigationOpts.prototype.run = function (a, state) { };
    /**
     * @param {?} a
     * @param {?} e
     * @return {?}
     */
    HandleNavigationOpts.prototype.onError = function (a, e) { };
}
/**
 * @template T, A
 * @param {?} opts
 * @return {?}
 */
export function pessimisticUpdate(opts) {
    return function (source) {
        return source.pipe(mapActionAndState(), concatMap(runWithErrorHandling(opts.run, opts.onError)));
    };
}
/**
 * @template T, A
 * @param {?} opts
 * @return {?}
 */
export function optimisticUpdate(opts) {
    return function (source) {
        return source.pipe(mapActionAndState(), concatMap(runWithErrorHandling(opts.run, opts.undoAction)));
    };
}
/**
 * @template T, A
 * @param {?} opts
 * @return {?}
 */
export function fetch(opts) {
    return function (source) {
        if (opts.id) {
            /** @type {?} */
            var groupedFetches = source.pipe(mapActionAndState(), groupBy(function (_a) {
                var _b = tslib_1.__read(_a, 2), action = _b[0], store = _b[1];
                return opts.id(action, store);
            }));
            return groupedFetches.pipe(mergeMap(function (pairs) {
                return pairs.pipe(switchMap(runWithErrorHandling(opts.run, opts.onError)));
            }));
        }
        return source.pipe(mapActionAndState(), concatMap(runWithErrorHandling(opts.run, opts.onError)));
    };
}
/**
 * @template T, A
 * @param {?} component
 * @param {?} opts
 * @return {?}
 */
export function navigation(component, opts) {
    return function (source) {
        /** @type {?} */
        var nav = source.pipe(mapActionAndState(), filter(function (_a) {
            var _b = tslib_1.__read(_a, 2), action = _b[0], state = _b[1];
            return isStateSnapshot(action);
        }), map(function (_a) {
            var _b = tslib_1.__read(_a, 2), action = _b[0], state = _b[1];
            if (!isStateSnapshot(action)) {
                // Because of the above filter we'll never get here,
                // but this properly type narrows `action`
                return;
            }
            return (/** @type {?} */ ([
                findSnapshot(component, action.payload.routerState.root),
                state
            ]));
        }), filter(function (_a) {
            var _b = tslib_1.__read(_a, 2), snapshot = _b[0], state = _b[1];
            return !!snapshot;
        }));
        return nav.pipe(switchMap(runWithErrorHandling(opts.run, opts.onError)));
    };
}
/**
 * @param {?} action
 * @return {?}
 */
function isStateSnapshot(action) {
    return action.type === ROUTER_NAVIGATION;
}
/**
 * @template T, A, R
 * @param {?} run
 * @param {?} onError
 * @return {?}
 */
function runWithErrorHandling(run, onError) {
    return function (_a) {
        var _b = tslib_1.__read(_a, 2), action = _b[0], state = _b[1];
        try {
            /** @type {?} */
            var r = wrapIntoObservable(run(action, state));
            return r.pipe(catchError(function (e) { return wrapIntoObservable(onError(action, e)); }));
        }
        catch (e) {
            return wrapIntoObservable(onError(action, e));
        }
    };
}
/**
 * \@whatItDoes maps Observable<Action | [Action, State]> to
 * Observable<[Action, State]>
 * @template T, A
 * @return {?}
 */
function mapActionAndState() {
    return function (source) {
        return source.pipe(map(function (value) {
            var _a = tslib_1.__read(normalizeActionAndState(value), 2), action = _a[0], store = _a[1];
            return (/** @type {?} */ ([action, store]));
        }));
    };
}
/**
 * \@whatItDoes Normalizes either a bare action or an array of action and state
 * into an array of action and state (or undefined)
 * @template T, A
 * @param {?} args
 * @return {?}
 */
function normalizeActionAndState(args) {
    var _a;
    /** @type {?} */
    var action;
    /** @type {?} */
    var state;
    if (args instanceof Array) {
        _a = tslib_1.__read(args, 2), action = _a[0], state = _a[1];
    }
    else {
        action = args;
    }
    return [action, state];
}
/**
 * \@whatItDoes Provides convenience methods for implementing common operations of persisting data.
 * @template T
 */
var DataPersistence = /** @class */ (function () {
    function DataPersistence(store, actions) {
        this.store = store;
        this.actions = actions;
    }
    /**
     *
     * @whatItDoes Handles pessimistic updates (updating the server first).
     *
     * Update the server implemented naively suffers from race conditions and poor error handling.
     *
     * `pessimisticUpdate` addresses these problems--it runs all fetches in order, which removes race conditions
     * and forces the developer to handle errors.
     *
     * ## Example:
     *
     * ```typescript
     * @Injectable()
     * class TodoEffects {
     *   @Effect() updateTodo = this.s.pessimisticUpdate<UpdateTodo>('UPDATE_TODO', {
     *     // provides an action and the current state of the store
     *     run(a, state) {
     *       // update the backend first, and then dispatch an action that will
     *       // update the client side
     *       return this.backend(state.user, a.payload).map(updated => ({
     *         type: 'TODO_UPDATED',
     *         payload: updated
     *       }));
     *     },
     *
     *     onError(a, e: any) {
     *       // we don't need to undo the changes on the client side.
     *       // we can dispatch an error, or simply log the error here and return `null`
     *       return null;
     *     }
     *   });
     *
     *   constructor(private s: DataPersistence<TodosState>, private backend: Backend) {}
     * }
     * ```
     *
     * Note that if you don't return a new action from the run callback, you must set the dispatch property
     * of the effect to false, like this:
     *
     * ```
     * class TodoEffects {
     *   @Effect({dispatch: false})
     *   updateTodo; //...
     * }
     * ```
     */
    /**
     *
     * \@whatItDoes Handles pessimistic updates (updating the server first).
     *
     * Update the server implemented naively suffers from race conditions and poor error handling.
     *
     * `pessimisticUpdate` addresses these problems--it runs all fetches in order, which removes race conditions
     * and forces the developer to handle errors.
     *
     * ## Example:
     *
     * ```typescript
     * \@Injectable()
     * class TodoEffects {
     * \@Effect() updateTodo = this.s.pessimisticUpdate<UpdateTodo>('UPDATE_TODO', {
     *     // provides an action and the current state of the store
     *     run(a, state) {
     *       // update the backend first, and then dispatch an action that will
     *       // update the client side
     *       return this.backend(state.user, a.payload).map(updated => ({
     *         type: 'TODO_UPDATED',
     *         payload: updated
     *       }));
     *     },
     *
     *     onError(a, e: any) {
     *       // we don't need to undo the changes on the client side.
     *       // we can dispatch an error, or simply log the error here and return `null`
     *       return null;
     *     }
     *   });
     *
     *   constructor(private s: DataPersistence<TodosState>, private backend: Backend) {}
     * }
     * ```
     *
     * Note that if you don't return a new action from the run callback, you must set the dispatch property
     * of the effect to false, like this:
     *
     * ```
     * class TodoEffects {
     * \@Effect({dispatch: false})
     *   updateTodo; //...
     * }
     * ```
     * @template A
     * @param {?} actionType
     * @param {?} opts
     * @return {?}
     */
    DataPersistence.prototype.pessimisticUpdate = /**
     *
     * \@whatItDoes Handles pessimistic updates (updating the server first).
     *
     * Update the server implemented naively suffers from race conditions and poor error handling.
     *
     * `pessimisticUpdate` addresses these problems--it runs all fetches in order, which removes race conditions
     * and forces the developer to handle errors.
     *
     * ## Example:
     *
     * ```typescript
     * \@Injectable()
     * class TodoEffects {
     * \@Effect() updateTodo = this.s.pessimisticUpdate<UpdateTodo>('UPDATE_TODO', {
     *     // provides an action and the current state of the store
     *     run(a, state) {
     *       // update the backend first, and then dispatch an action that will
     *       // update the client side
     *       return this.backend(state.user, a.payload).map(updated => ({
     *         type: 'TODO_UPDATED',
     *         payload: updated
     *       }));
     *     },
     *
     *     onError(a, e: any) {
     *       // we don't need to undo the changes on the client side.
     *       // we can dispatch an error, or simply log the error here and return `null`
     *       return null;
     *     }
     *   });
     *
     *   constructor(private s: DataPersistence<TodosState>, private backend: Backend) {}
     * }
     * ```
     *
     * Note that if you don't return a new action from the run callback, you must set the dispatch property
     * of the effect to false, like this:
     *
     * ```
     * class TodoEffects {
     * \@Effect({dispatch: false})
     *   updateTodo; //...
     * }
     * ```
     * @template A
     * @param {?} actionType
     * @param {?} opts
     * @return {?}
     */
    function (actionType, opts) {
        return this.actions.pipe(ofType(actionType), withLatestFrom(this.store), pessimisticUpdate(opts));
    };
    /**
     *
     * @whatItDoes Handles optimistic updates (updating the client first).
     *
     * `optimisticUpdate` addresses these problems--it runs all fetches in order, which removes race conditions
     * and forces the developer to handle errors.
     *
     * `optimisticUpdate` is different from `pessimisticUpdate`. In case of a failure, when using `optimisticUpdate`,
     * the developer already updated the state locally, so the developer must provide an undo action.
     *
     * The error handling must be done in the callback, or by means of the undo action.
     *
     * ## Example:
     *
     * ```typescript
     * @Injectable()
     * class TodoEffects {
     *   @Effect() updateTodo = this.s.optimisticUpdate<UpdateTodo>('UPDATE_TODO', {
     *     // provides an action and the current state of the store
     *     run: (a, state) => {
     *       return this.backend(state.user, a.payload);
     *     },
     *
     *     undoAction: (a, e: any) => {
     *       // dispatch an undo action to undo the changes in the client state
     *       return ({
     *         type: 'UNDO_UPDATE_TODO',
     *         payload: a
     *       });
     *     }
     *   });
     *
     *   constructor(private s: DataPersistence<TodosState>, private backend: Backend) {}
     * }
     * ```
     *
     * Note that if you don't return a new action from the run callback, you must set the dispatch property
     * of the effect to false, like this:
     *
     * ```
     * class TodoEffects {
     *   @Effect({dispatch: false})
     *   updateTodo; //...
     * }
     * ```
     */
    /**
     *
     * \@whatItDoes Handles optimistic updates (updating the client first).
     *
     * `optimisticUpdate` addresses these problems--it runs all fetches in order, which removes race conditions
     * and forces the developer to handle errors.
     *
     * `optimisticUpdate` is different from `pessimisticUpdate`. In case of a failure, when using `optimisticUpdate`,
     * the developer already updated the state locally, so the developer must provide an undo action.
     *
     * The error handling must be done in the callback, or by means of the undo action.
     *
     * ## Example:
     *
     * ```typescript
     * \@Injectable()
     * class TodoEffects {
     * \@Effect() updateTodo = this.s.optimisticUpdate<UpdateTodo>('UPDATE_TODO', {
     *     // provides an action and the current state of the store
     *     run: (a, state) => {
     *       return this.backend(state.user, a.payload);
     *     },
     *
     *     undoAction: (a, e: any) => {
     *       // dispatch an undo action to undo the changes in the client state
     *       return ({
     *         type: 'UNDO_UPDATE_TODO',
     *         payload: a
     *       });
     *     }
     *   });
     *
     *   constructor(private s: DataPersistence<TodosState>, private backend: Backend) {}
     * }
     * ```
     *
     * Note that if you don't return a new action from the run callback, you must set the dispatch property
     * of the effect to false, like this:
     *
     * ```
     * class TodoEffects {
     * \@Effect({dispatch: false})
     *   updateTodo; //...
     * }
     * ```
     * @template A
     * @param {?} actionType
     * @param {?} opts
     * @return {?}
     */
    DataPersistence.prototype.optimisticUpdate = /**
     *
     * \@whatItDoes Handles optimistic updates (updating the client first).
     *
     * `optimisticUpdate` addresses these problems--it runs all fetches in order, which removes race conditions
     * and forces the developer to handle errors.
     *
     * `optimisticUpdate` is different from `pessimisticUpdate`. In case of a failure, when using `optimisticUpdate`,
     * the developer already updated the state locally, so the developer must provide an undo action.
     *
     * The error handling must be done in the callback, or by means of the undo action.
     *
     * ## Example:
     *
     * ```typescript
     * \@Injectable()
     * class TodoEffects {
     * \@Effect() updateTodo = this.s.optimisticUpdate<UpdateTodo>('UPDATE_TODO', {
     *     // provides an action and the current state of the store
     *     run: (a, state) => {
     *       return this.backend(state.user, a.payload);
     *     },
     *
     *     undoAction: (a, e: any) => {
     *       // dispatch an undo action to undo the changes in the client state
     *       return ({
     *         type: 'UNDO_UPDATE_TODO',
     *         payload: a
     *       });
     *     }
     *   });
     *
     *   constructor(private s: DataPersistence<TodosState>, private backend: Backend) {}
     * }
     * ```
     *
     * Note that if you don't return a new action from the run callback, you must set the dispatch property
     * of the effect to false, like this:
     *
     * ```
     * class TodoEffects {
     * \@Effect({dispatch: false})
     *   updateTodo; //...
     * }
     * ```
     * @template A
     * @param {?} actionType
     * @param {?} opts
     * @return {?}
     */
    function (actionType, opts) {
        return this.actions.pipe(ofType(actionType), withLatestFrom(this.store), optimisticUpdate(opts));
    };
    /**
     *
     * @whatItDoes Handles data fetching.
     *
     * Data fetching implemented naively suffers from race conditions and poor error handling.
     *
     * `fetch` addresses these problems--it runs all fetches in order, which removes race conditions
     * and forces the developer to handle errors.
     *
     * ## Example:
     *
     * ```typescript
     * @Injectable()
     * class TodoEffects {
     *   @Effect() loadTodos = this.s.fetch<GetTodos>('GET_TODOS', {
     *     // provides an action and the current state of the store
     *     run: (a, state) => {
     *       return this.backend(state.user, a.payload).map(r => ({
     *         type: 'TODOS',
     *         payload: r
     *       });
     *     },
     *
     *     onError: (a, e: any) => {
     *       // dispatch an undo action to undo the changes in the client state
     *     }
     *   });
     *
     *   constructor(private s: DataPersistence<TodosState>, private backend: Backend) {}
     * }
     * ```
     *
     * This is correct, but because it set the concurrency to 1, it may not be performant.
     *
     * To fix that, you can provide the `id` function, like this:
     *
     * ```typescript
     * @Injectable()
     * class TodoEffects {
     *   @Effect() loadTodo = this.s.fetch<GetTodo>('GET_TODO', {
     *     id: (a, state) => {
     *       return a.payload.id;
     *     }
     *
     *     // provides an action and the current state of the store
     *     run: (a, state) => {
     *       return this.backend(state.user, a.payload).map(r => ({
     *         type: 'TODO',
     *         payload: r
     *       });
     *     },
     *
     *     onError: (a, e: any) => {
     *       // dispatch an undo action to undo the changes in the client state
     *       return null;
     *     }
     *   });
     *
     *   constructor(private s: DataPersistence<TodosState>, private backend: Backend) {}
     * }
     * ```
     *
     * With this setup, the requests for Todo 1 will run concurrently with the requests for Todo 2.
     *
     * In addition, if DataPersistence notices that there are multiple requests for Todo 1 scheduled,
     * it will only run the last one.
     */
    /**
     *
     * \@whatItDoes Handles data fetching.
     *
     * Data fetching implemented naively suffers from race conditions and poor error handling.
     *
     * `fetch` addresses these problems--it runs all fetches in order, which removes race conditions
     * and forces the developer to handle errors.
     *
     * ## Example:
     *
     * ```typescript
     * \@Injectable()
     * class TodoEffects {
     * \@Effect() loadTodos = this.s.fetch<GetTodos>('GET_TODOS', {
     *     // provides an action and the current state of the store
     *     run: (a, state) => {
     *       return this.backend(state.user, a.payload).map(r => ({
     *         type: 'TODOS',
     *         payload: r
     *       });
     *     },
     *
     *     onError: (a, e: any) => {
     *       // dispatch an undo action to undo the changes in the client state
     *     }
     *   });
     *
     *   constructor(private s: DataPersistence<TodosState>, private backend: Backend) {}
     * }
     * ```
     *
     * This is correct, but because it set the concurrency to 1, it may not be performant.
     *
     * To fix that, you can provide the `id` function, like this:
     *
     * ```typescript / loadTodo = this.s.fetch<GetTodo>('GET_TODO', {
     *     id: (a, state) => {
     *       return a.payload.id;
     *     }
     *
     *     // provides an action and the current state of the store
     *     run: (a, state) => {
     *       return this.backend(state.user, a.payload).map(r => ({
     *         type: 'TODO',
     *         payload: r
     *       });
     *     },
     *
     *     onError: (a, e: any) => {
     *       // dispatch an undo action to undo the changes in the client state
     *       return null;
     *     }
     *   });
     *
     *   constructor(private s: DataPersistence<TodosState>, private backend: Backend) {}
     * }
     * ```
     *
     * With this setup, the requests for Todo 1 will run concurrently with the requests for Todo 2.
     *
     * In addition, if DataPersistence notices that there are multiple requests for Todo 1 scheduled,
     * it will only run the last one.
     * @template A
     * @param {?} actionType
     * @param {?} opts
     * @return {?}
     */
    DataPersistence.prototype.fetch = /**
     *
     * \@whatItDoes Handles data fetching.
     *
     * Data fetching implemented naively suffers from race conditions and poor error handling.
     *
     * `fetch` addresses these problems--it runs all fetches in order, which removes race conditions
     * and forces the developer to handle errors.
     *
     * ## Example:
     *
     * ```typescript
     * \@Injectable()
     * class TodoEffects {
     * \@Effect() loadTodos = this.s.fetch<GetTodos>('GET_TODOS', {
     *     // provides an action and the current state of the store
     *     run: (a, state) => {
     *       return this.backend(state.user, a.payload).map(r => ({
     *         type: 'TODOS',
     *         payload: r
     *       });
     *     },
     *
     *     onError: (a, e: any) => {
     *       // dispatch an undo action to undo the changes in the client state
     *     }
     *   });
     *
     *   constructor(private s: DataPersistence<TodosState>, private backend: Backend) {}
     * }
     * ```
     *
     * This is correct, but because it set the concurrency to 1, it may not be performant.
     *
     * To fix that, you can provide the `id` function, like this:
     *
     * ```typescript / loadTodo = this.s.fetch<GetTodo>('GET_TODO', {
     *     id: (a, state) => {
     *       return a.payload.id;
     *     }
     *
     *     // provides an action and the current state of the store
     *     run: (a, state) => {
     *       return this.backend(state.user, a.payload).map(r => ({
     *         type: 'TODO',
     *         payload: r
     *       });
     *     },
     *
     *     onError: (a, e: any) => {
     *       // dispatch an undo action to undo the changes in the client state
     *       return null;
     *     }
     *   });
     *
     *   constructor(private s: DataPersistence<TodosState>, private backend: Backend) {}
     * }
     * ```
     *
     * With this setup, the requests for Todo 1 will run concurrently with the requests for Todo 2.
     *
     * In addition, if DataPersistence notices that there are multiple requests for Todo 1 scheduled,
     * it will only run the last one.
     * @template A
     * @param {?} actionType
     * @param {?} opts
     * @return {?}
     */
    function (actionType, opts) {
        return this.actions.pipe(ofType(actionType), withLatestFrom(this.store), fetch(opts));
    };
    /**
     * @whatItDoes Handles data fetching as part of router navigation.
     *
     * Data fetching implemented naively suffers from race conditions and poor error handling.
     *
     * `navigation` addresses these problems.
     *
     * It checks if an activated router state contains the passed in component type, and, if it does, runs the `run`
     * callback. It provides the activated snapshot associated with the component and the current state. And it only runs
     * the last request.
     *
     * ## Example:
     *
     * ```typescript
     * @Injectable()
     * class TodoEffects {
     *   @Effect() loadTodo = this.s.navigation(TodoComponent, {
     *     run: (a, state) => {
     *       return this.backend.fetchTodo(a.params['id']).map(todo => ({
     *         type: 'TODO_LOADED',
     *         payload: todo
     *       }));
     *     },
     *     onError: (a, e: any) => {
     *       // we can log and error here and return null
     *       // we can also navigate back
     *       return null;
     *     }
     *   });
     *   constructor(private s: DataPersistence<TodosState>, private backend: Backend) {}
     * }
     * ```
     */
    /**
     * \@whatItDoes Handles data fetching as part of router navigation.
     *
     * Data fetching implemented naively suffers from race conditions and poor error handling.
     *
     * `navigation` addresses these problems.
     *
     * It checks if an activated router state contains the passed in component type, and, if it does, runs the `run`
     * callback. It provides the activated snapshot associated with the component and the current state. And it only runs
     * the last request.
     *
     * ## Example:
     *
     * ```typescript
     * \@Injectable()
     * class TodoEffects {
     * \@Effect() loadTodo = this.s.navigation(TodoComponent, {
     *     run: (a, state) => {
     *       return this.backend.fetchTodo(a.params['id']).map(todo => ({
     *         type: 'TODO_LOADED',
     *         payload: todo
     *       }));
     *     },
     *     onError: (a, e: any) => {
     *       // we can log and error here and return null
     *       // we can also navigate back
     *       return null;
     *     }
     *   });
     *   constructor(private s: DataPersistence<TodosState>, private backend: Backend) {}
     * }
     * ```
     * @param {?} component
     * @param {?} opts
     * @return {?}
     */
    DataPersistence.prototype.navigation = /**
     * \@whatItDoes Handles data fetching as part of router navigation.
     *
     * Data fetching implemented naively suffers from race conditions and poor error handling.
     *
     * `navigation` addresses these problems.
     *
     * It checks if an activated router state contains the passed in component type, and, if it does, runs the `run`
     * callback. It provides the activated snapshot associated with the component and the current state. And it only runs
     * the last request.
     *
     * ## Example:
     *
     * ```typescript
     * \@Injectable()
     * class TodoEffects {
     * \@Effect() loadTodo = this.s.navigation(TodoComponent, {
     *     run: (a, state) => {
     *       return this.backend.fetchTodo(a.params['id']).map(todo => ({
     *         type: 'TODO_LOADED',
     *         payload: todo
     *       }));
     *     },
     *     onError: (a, e: any) => {
     *       // we can log and error here and return null
     *       // we can also navigate back
     *       return null;
     *     }
     *   });
     *   constructor(private s: DataPersistence<TodosState>, private backend: Backend) {}
     * }
     * ```
     * @param {?} component
     * @param {?} opts
     * @return {?}
     */
    function (component, opts) {
        return this.actions.pipe(withLatestFrom(this.store), navigation(component, opts));
    };
    DataPersistence.decorators = [
        { type: Injectable }
    ];
    /** @nocollapse */
    DataPersistence.ctorParameters = function () { return [
        { type: Store },
        { type: Actions }
    ]; };
    return DataPersistence;
}());
export { DataPersistence };
if (false) {
    /** @type {?} */
    DataPersistence.prototype.store;
    /** @type {?} */
    DataPersistence.prototype.actions;
}
/**
 * @param {?} component
 * @param {?} s
 * @return {?}
 */
function findSnapshot(component, s) {
    var e_1, _a;
    if (s.routeConfig && s.routeConfig.component === component) {
        return s;
    }
    try {
        for (var _b = tslib_1.__values(s.children), _c = _b.next(); !_c.done; _c = _b.next()) {
            var c = _c.value;
            /** @type {?} */
            var ss = findSnapshot(component, c);
            if (ss) {
                return ss;
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return null;
}
/**
 * @template O
 * @param {?} obj
 * @return {?}
 */
function wrapIntoObservable(obj) {
    if (!!obj && obj instanceof Observable) {
        return obj;
    }
    else if (!obj) {
        return of();
    }
    else {
        return of((/** @type {?} */ (obj)));
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0YS1wZXJzaXN0ZW5jZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BucndsL254LyIsInNvdXJjZXMiOlsic3JjL2RhdGEtcGVyc2lzdGVuY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSxPQUFPLEVBQUUsVUFBVSxFQUFRLE1BQU0sZUFBZSxDQUFDO0FBRWpELE9BQU8sRUFBRSxPQUFPLEVBQUUsTUFBTSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQ2hELE9BQU8sRUFBRSxpQkFBaUIsRUFBMEIsTUFBTSxvQkFBb0IsQ0FBQztBQUMvRSxPQUFPLEVBQVUsS0FBSyxFQUFFLE1BQU0sYUFBYSxDQUFDO0FBQzVDLE9BQU8sRUFBRSxVQUFVLEVBQUUsRUFBRSxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBQ3RDLE9BQU8sRUFDTCxVQUFVLEVBQ1YsU0FBUyxFQUNULE1BQU0sRUFDTixPQUFPLEVBQ1AsR0FBRyxFQUNILFFBQVEsRUFDUixTQUFTLEVBQ1QsY0FBYyxFQUNmLE1BQU0sZ0JBQWdCLENBQUM7Ozs7OztBQUt4QiwyQ0FHQzs7Ozs7OztJQUZDLDhEQUF5RDs7Ozs7O0lBQ3pELDhEQUE2Qzs7Ozs7OztBQUsvQywwQ0FHQzs7Ozs7OztJQUZDLDZEQUF5RDs7Ozs7O0lBQ3pELGdFQUFzRDs7Ozs7OztBQU14RCwrQkFJQzs7Ozs7OztJQUhDLGlEQUEwQjs7Ozs7O0lBQzFCLGtEQUF5RDs7Ozs7O0lBQ3pELGtEQUE4Qzs7Ozs7OztBQU1oRCwwQ0FHQzs7Ozs7OztJQUZDLDZEQUE4RTs7Ozs7O0lBQzlFLDZEQUFtRTs7Ozs7OztBQU1yRSxNQUFNLFVBQVUsaUJBQWlCLENBQy9CLElBQWlDO0lBRWpDLE9BQU8sVUFBQyxNQUErQjtRQUNyQyxPQUFPLE1BQU0sQ0FBQyxJQUFJLENBQ2hCLGlCQUFpQixFQUFFLEVBQ25CLFNBQVMsQ0FBQyxvQkFBb0IsQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUN4RCxD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Ozs7O0FBRUQsU0FBUyxrQkFBa0IsQ0FBSSxHQUE2QjtJQUMxRCxJQUFJLENBQUMsQ0FBQyxHQUFHLElBQUksR0FBRyxZQUFZLFVBQVUsRUFBRTtRQUN0QyxPQUFPLEdBQUcsQ0FBQztLQUNaO1NBQU0sSUFBSSxDQUFDLEdBQUcsRUFBRTtRQUNmLE9BQU8sRUFBRSxFQUFFLENBQUM7S0FDYjtTQUFNO1FBQ0wsT0FBTyxFQUFFLENBQUMsbUJBQUEsR0FBRyxFQUFLLENBQUMsQ0FBQztLQUNyQjtBQUNILENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbmplY3RhYmxlLCBUeXBlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBBY3RpdmF0ZWRSb3V0ZVNuYXBzaG90LCBSb3V0ZXJTdGF0ZVNuYXBzaG90IH0gZnJvbSAnQGFuZ3VsYXIvcm91dGVyJztcbmltcG9ydCB7IEFjdGlvbnMsIG9mVHlwZSB9IGZyb20gJ0BuZ3J4L2VmZmVjdHMnO1xuaW1wb3J0IHsgUk9VVEVSX05BVklHQVRJT04sIFJvdXRlck5hdmlnYXRpb25BY3Rpb24gfSBmcm9tICdAbmdyeC9yb3V0ZXItc3RvcmUnO1xuaW1wb3J0IHsgQWN0aW9uLCBTdG9yZSB9IGZyb20gJ0BuZ3J4L3N0b3JlJztcbmltcG9ydCB7IE9ic2VydmFibGUsIG9mIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQge1xuICBjYXRjaEVycm9yLFxuICBjb25jYXRNYXAsXG4gIGZpbHRlcixcbiAgZ3JvdXBCeSxcbiAgbWFwLFxuICBtZXJnZU1hcCxcbiAgc3dpdGNoTWFwLFxuICB3aXRoTGF0ZXN0RnJvbVxufSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5cbi8qKlxuICogU2VlIHtAbGluayBEYXRhUGVyc2lzdGVuY2UucGVzc2ltaXN0aWNVcGRhdGV9IGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFBlc3NpbWlzdGljVXBkYXRlT3B0czxULCBBPiB7XG4gIHJ1bihhOiBBLCBzdGF0ZT86IFQpOiBPYnNlcnZhYmxlPEFjdGlvbj4gfCBBY3Rpb24gfCB2b2lkO1xuICBvbkVycm9yKGE6IEEsIGU6IGFueSk6IE9ic2VydmFibGU8YW55PiB8IGFueTtcbn1cbi8qKlxuICogU2VlIHtAbGluayBEYXRhUGVyc2lzdGVuY2UucGVzc2ltaXN0aWNVcGRhdGV9IGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIE9wdGltaXN0aWNVcGRhdGVPcHRzPFQsIEE+IHtcbiAgcnVuKGE6IEEsIHN0YXRlPzogVCk6IE9ic2VydmFibGU8QWN0aW9uPiB8IEFjdGlvbiB8IHZvaWQ7XG4gIHVuZG9BY3Rpb24oYTogQSwgZTogYW55KTogT2JzZXJ2YWJsZTxBY3Rpb24+IHwgQWN0aW9uO1xufVxuXG4vKipcbiAqIFNlZSB7QGxpbmsgRGF0YVBlcnNpc3RlbmNlLmZldGNofSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBGZXRjaE9wdHM8VCwgQT4ge1xuICBpZD8oYTogQSwgc3RhdGU/OiBUKTogYW55O1xuICBydW4oYTogQSwgc3RhdGU/OiBUKTogT2JzZXJ2YWJsZTxBY3Rpb24+IHwgQWN0aW9uIHwgdm9pZDtcbiAgb25FcnJvcj8oYTogQSwgZTogYW55KTogT2JzZXJ2YWJsZTxhbnk+IHwgYW55O1xufVxuXG4vKipcbiAqIFNlZSB7QGxpbmsgRGF0YVBlcnNpc3RlbmNlLm5hdmlnYXRpb259IGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIEhhbmRsZU5hdmlnYXRpb25PcHRzPFQ+IHtcbiAgcnVuKGE6IEFjdGl2YXRlZFJvdXRlU25hcHNob3QsIHN0YXRlPzogVCk6IE9ic2VydmFibGU8QWN0aW9uPiB8IEFjdGlvbiB8IHZvaWQ7XG4gIG9uRXJyb3I/KGE6IEFjdGl2YXRlZFJvdXRlU25hcHNob3QsIGU6IGFueSk6IE9ic2VydmFibGU8YW55PiB8IGFueTtcbn1cblxuZXhwb3J0IHR5cGUgQWN0aW9uT3JBY3Rpb25XaXRoU3RhdGU8VCwgQT4gPSBBIHwgW0EsIFRdO1xuZXhwb3J0IHR5cGUgQWN0aW9uU3RhdGVTdHJlYW08VCwgQT4gPSBPYnNlcnZhYmxlPEFjdGlvbk9yQWN0aW9uV2l0aFN0YXRlPFQsIEE+PjtcblxuZXhwb3J0IGZ1bmN0aW9uIHBlc3NpbWlzdGljVXBkYXRlPFQsIEEgZXh0ZW5kcyBBY3Rpb24+KFxuICBvcHRzOiBQZXNzaW1pc3RpY1VwZGF0ZU9wdHM8VCwgQT5cbikge1xuICByZXR1cm4gKHNvdXJjZTogQWN0aW9uU3RhdGVTdHJlYW08VCwgQT4pOiBPYnNlcnZhYmxlPEFjdGlvbj4gPT4ge1xuICAgIHJldHVybiBzb3VyY2UucGlwZShcbiAgICAgIG1hcEFjdGlvbkFuZFN0YXRlKCksXG4gICAgICBjb25jYXRNYXAocnVuV2l0aEVycm9ySGFuZGxpbmcob3B0cy5ydW4sIG9wdHMub25FcnJvcikpXG4gICAgKTtcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG9wdGltaXN0aWNVcGRhdGU8VCwgQSBleHRlbmRzIEFjdGlvbj4oXG4gIG9wdHM6IE9wdGltaXN0aWNVcGRhdGVPcHRzPFQsIEE+XG4pIHtcbiAgcmV0dXJuIChzb3VyY2U6IEFjdGlvblN0YXRlU3RyZWFtPFQsIEE+KTogT2JzZXJ2YWJsZTxBY3Rpb24+ID0+IHtcbiAgICByZXR1cm4gc291cmNlLnBpcGUoXG4gICAgICBtYXBBY3Rpb25BbmRTdGF0ZSgpLFxuICAgICAgY29uY2F0TWFwKHJ1bldpdGhFcnJvckhhbmRsaW5nKG9wdHMucnVuLCBvcHRzLnVuZG9BY3Rpb24pKVxuICAgICk7XG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmZXRjaDxULCBBIGV4dGVuZHMgQWN0aW9uPihvcHRzOiBGZXRjaE9wdHM8VCwgQT4pIHtcbiAgcmV0dXJuIChzb3VyY2U6IEFjdGlvblN0YXRlU3RyZWFtPFQsIEE+KTogT2JzZXJ2YWJsZTxBY3Rpb24+ID0+IHtcbiAgICBpZiAob3B0cy5pZCkge1xuICAgICAgY29uc3QgZ3JvdXBlZEZldGNoZXMgPSBzb3VyY2UucGlwZShcbiAgICAgICAgbWFwQWN0aW9uQW5kU3RhdGUoKSxcbiAgICAgICAgZ3JvdXBCeSgoW2FjdGlvbiwgc3RvcmVdKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIG9wdHMuaWQoYWN0aW9uLCBzdG9yZSk7XG4gICAgICAgIH0pXG4gICAgICApO1xuXG4gICAgICByZXR1cm4gZ3JvdXBlZEZldGNoZXMucGlwZShcbiAgICAgICAgbWVyZ2VNYXAocGFpcnMgPT5cbiAgICAgICAgICBwYWlycy5waXBlKHN3aXRjaE1hcChydW5XaXRoRXJyb3JIYW5kbGluZyhvcHRzLnJ1biwgb3B0cy5vbkVycm9yKSkpXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNvdXJjZS5waXBlKFxuICAgICAgbWFwQWN0aW9uQW5kU3RhdGUoKSxcbiAgICAgIGNvbmNhdE1hcChydW5XaXRoRXJyb3JIYW5kbGluZyhvcHRzLnJ1biwgb3B0cy5vbkVycm9yKSlcbiAgICApO1xuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbmF2aWdhdGlvbjxULCBBIGV4dGVuZHMgQWN0aW9uPihcbiAgY29tcG9uZW50OiBUeXBlPGFueT4sXG4gIG9wdHM6IEhhbmRsZU5hdmlnYXRpb25PcHRzPFQ+XG4pIHtcbiAgcmV0dXJuIChzb3VyY2U6IEFjdGlvblN0YXRlU3RyZWFtPFQsIEE+KSA9PiB7XG4gICAgY29uc3QgbmF2ID0gc291cmNlLnBpcGUoXG4gICAgICBtYXBBY3Rpb25BbmRTdGF0ZSgpLFxuICAgICAgZmlsdGVyKChbYWN0aW9uLCBzdGF0ZV0pID0+IGlzU3RhdGVTbmFwc2hvdChhY3Rpb24pKSxcbiAgICAgIG1hcCgoW2FjdGlvbiwgc3RhdGVdKSA9PiB7XG4gICAgICAgIGlmICghaXNTdGF0ZVNuYXBzaG90KGFjdGlvbikpIHtcbiAgICAgICAgICAvLyBCZWNhdXNlIG9mIHRoZSBhYm92ZSBmaWx0ZXIgd2UnbGwgbmV2ZXIgZ2V0IGhlcmUsXG4gICAgICAgICAgLy8gYnV0IHRoaXMgcHJvcGVybHkgdHlwZSBuYXJyb3dzIGBhY3Rpb25gXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICBmaW5kU25hcHNob3QoY29tcG9uZW50LCBhY3Rpb24ucGF5bG9hZC5yb3V0ZXJTdGF0ZS5yb290KSxcbiAgICAgICAgICBzdGF0ZVxuICAgICAgICBdIGFzIFtBY3RpdmF0ZWRSb3V0ZVNuYXBzaG90LCBUXTtcbiAgICAgIH0pLFxuICAgICAgZmlsdGVyKChbc25hcHNob3QsIHN0YXRlXSkgPT4gISFzbmFwc2hvdClcbiAgICApO1xuXG4gICAgcmV0dXJuIG5hdi5waXBlKHN3aXRjaE1hcChydW5XaXRoRXJyb3JIYW5kbGluZyhvcHRzLnJ1biwgb3B0cy5vbkVycm9yKSkpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBpc1N0YXRlU25hcHNob3QoXG4gIGFjdGlvbjogYW55XG4pOiBhY3Rpb24gaXMgUm91dGVyTmF2aWdhdGlvbkFjdGlvbjxSb3V0ZXJTdGF0ZVNuYXBzaG90PiB7XG4gIHJldHVybiBhY3Rpb24udHlwZSA9PT0gUk9VVEVSX05BVklHQVRJT047XG59XG5cbmZ1bmN0aW9uIHJ1bldpdGhFcnJvckhhbmRsaW5nPFQsIEEsIFI+KFxuICBydW46IChhOiBBLCBzdGF0ZT86IFQpID0+IE9ic2VydmFibGU8Uj4gfCBSIHwgdm9pZCxcbiAgb25FcnJvcjogYW55XG4pIHtcbiAgcmV0dXJuIChbYWN0aW9uLCBzdGF0ZV06IFtBLCBUXSk6IE9ic2VydmFibGU8Uj4gPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByID0gd3JhcEludG9PYnNlcnZhYmxlKHJ1bihhY3Rpb24sIHN0YXRlKSk7XG4gICAgICByZXR1cm4gci5waXBlKGNhdGNoRXJyb3IoZSA9PiB3cmFwSW50b09ic2VydmFibGUob25FcnJvcihhY3Rpb24sIGUpKSkpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiB3cmFwSW50b09ic2VydmFibGUob25FcnJvcihhY3Rpb24sIGUpKTtcbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogQHdoYXRJdERvZXMgbWFwcyBPYnNlcnZhYmxlPEFjdGlvbiB8IFtBY3Rpb24sIFN0YXRlXT4gdG9cbiAqIE9ic2VydmFibGU8W0FjdGlvbiwgU3RhdGVdPlxuICovXG5mdW5jdGlvbiBtYXBBY3Rpb25BbmRTdGF0ZTxULCBBPigpIHtcbiAgcmV0dXJuIChzb3VyY2U6IE9ic2VydmFibGU8QWN0aW9uT3JBY3Rpb25XaXRoU3RhdGU8VCwgQT4+KSA9PiB7XG4gICAgcmV0dXJuIHNvdXJjZS5waXBlKFxuICAgICAgbWFwKHZhbHVlID0+IHtcbiAgICAgICAgY29uc3QgW2FjdGlvbiwgc3RvcmVdID0gbm9ybWFsaXplQWN0aW9uQW5kU3RhdGUodmFsdWUpO1xuICAgICAgICByZXR1cm4gW2FjdGlvbiwgc3RvcmVdIGFzIFtBLCBUXTtcbiAgICAgIH0pXG4gICAgKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBAd2hhdEl0RG9lcyBOb3JtYWxpemVzIGVpdGhlciBhIGJhcmUgYWN0aW9uIG9yIGFuIGFycmF5IG9mIGFjdGlvbiBhbmQgc3RhdGVcbiAqIGludG8gYW4gYXJyYXkgb2YgYWN0aW9uIGFuZCBzdGF0ZSAob3IgdW5kZWZpbmVkKVxuICovXG5mdW5jdGlvbiBub3JtYWxpemVBY3Rpb25BbmRTdGF0ZTxULCBBPihcbiAgYXJnczogQWN0aW9uT3JBY3Rpb25XaXRoU3RhdGU8VCwgQT5cbik6IFtBLCBUXSB7XG4gIGxldCBhY3Rpb246IEEsIHN0YXRlOiBUO1xuXG4gIGlmIChhcmdzIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICBbYWN0aW9uLCBzdGF0ZV0gPSBhcmdzO1xuICB9IGVsc2Uge1xuICAgIGFjdGlvbiA9IGFyZ3M7XG4gIH1cblxuICByZXR1cm4gW2FjdGlvbiwgc3RhdGVdO1xufVxuXG4vKipcbiAqIEB3aGF0SXREb2VzIFByb3ZpZGVzIGNvbnZlbmllbmNlIG1ldGhvZHMgZm9yIGltcGxlbWVudGluZyBjb21tb24gb3BlcmF0aW9ucyBvZiBwZXJzaXN0aW5nIGRhdGEuXG4gKi9cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBEYXRhUGVyc2lzdGVuY2U8VD4ge1xuICBjb25zdHJ1Y3RvcihwdWJsaWMgc3RvcmU6IFN0b3JlPFQ+LCBwdWJsaWMgYWN0aW9uczogQWN0aW9ucykge31cblxuICAvKipcbiAgICpcbiAgICogQHdoYXRJdERvZXMgSGFuZGxlcyBwZXNzaW1pc3RpYyB1cGRhdGVzICh1cGRhdGluZyB0aGUgc2VydmVyIGZpcnN0KS5cbiAgICpcbiAgICogVXBkYXRlIHRoZSBzZXJ2ZXIgaW1wbGVtZW50ZWQgbmFpdmVseSBzdWZmZXJzIGZyb20gcmFjZSBjb25kaXRpb25zIGFuZCBwb29yIGVycm9yIGhhbmRsaW5nLlxuICAgKlxuICAgKiBgcGVzc2ltaXN0aWNVcGRhdGVgIGFkZHJlc3NlcyB0aGVzZSBwcm9ibGVtcy0taXQgcnVucyBhbGwgZmV0Y2hlcyBpbiBvcmRlciwgd2hpY2ggcmVtb3ZlcyByYWNlIGNvbmRpdGlvbnNcbiAgICogYW5kIGZvcmNlcyB0aGUgZGV2ZWxvcGVyIHRvIGhhbmRsZSBlcnJvcnMuXG4gICAqXG4gICAqICMjIEV4YW1wbGU6XG4gICAqXG4gICAqIGBgYHR5cGVzY3JpcHRcbiAgICogQEluamVjdGFibGUoKVxuICAgKiBjbGFzcyBUb2RvRWZmZWN0cyB7XG4gICAqICAgQEVmZmVjdCgpIHVwZGF0ZVRvZG8gPSB0aGlzLnMucGVzc2ltaXN0aWNVcGRhdGU8VXBkYXRlVG9kbz4oJ1VQREFURV9UT0RPJywge1xuICAgKiAgICAgLy8gcHJvdmlkZXMgYW4gYWN0aW9uIGFuZCB0aGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgc3RvcmVcbiAgICogICAgIHJ1bihhLCBzdGF0ZSkge1xuICAgKiAgICAgICAvLyB1cGRhdGUgdGhlIGJhY2tlbmQgZmlyc3QsIGFuZCB0aGVuIGRpc3BhdGNoIGFuIGFjdGlvbiB0aGF0IHdpbGxcbiAgICogICAgICAgLy8gdXBkYXRlIHRoZSBjbGllbnQgc2lkZVxuICAgKiAgICAgICByZXR1cm4gdGhpcy5iYWNrZW5kKHN0YXRlLnVzZXIsIGEucGF5bG9hZCkubWFwKHVwZGF0ZWQgPT4gKHtcbiAgICogICAgICAgICB0eXBlOiAnVE9ET19VUERBVEVEJyxcbiAgICogICAgICAgICBwYXlsb2FkOiB1cGRhdGVkXG4gICAqICAgICAgIH0pKTtcbiAgICogICAgIH0sXG4gICAqXG4gICAqICAgICBvbkVycm9yKGEsIGU6IGFueSkge1xuICAgKiAgICAgICAvLyB3ZSBkb24ndCBuZWVkIHRvIHVuZG8gdGhlIGNoYW5nZXMgb24gdGhlIGNsaWVudCBzaWRlLlxuICAgKiAgICAgICAvLyB3ZSBjYW4gZGlzcGF0Y2ggYW4gZXJyb3IsIG9yIHNpbXBseSBsb2cgdGhlIGVycm9yIGhlcmUgYW5kIHJldHVybiBgbnVsbGBcbiAgICogICAgICAgcmV0dXJuIG51bGw7XG4gICAqICAgICB9XG4gICAqICAgfSk7XG4gICAqXG4gICAqICAgY29uc3RydWN0b3IocHJpdmF0ZSBzOiBEYXRhUGVyc2lzdGVuY2U8VG9kb3NTdGF0ZT4sIHByaXZhdGUgYmFja2VuZDogQmFja2VuZCkge31cbiAgICogfVxuICAgKiBgYGBcbiAgICpcbiAgICogTm90ZSB0aGF0IGlmIHlvdSBkb24ndCByZXR1cm4gYSBuZXcgYWN0aW9uIGZyb20gdGhlIHJ1biBjYWxsYmFjaywgeW91IG11c3Qgc2V0IHRoZSBkaXNwYXRjaCBwcm9wZXJ0eVxuICAgKiBvZiB0aGUgZWZmZWN0IHRvIGZhbHNlLCBsaWtlIHRoaXM6XG4gICAqXG4gICAqIGBgYFxuICAgKiBjbGFzcyBUb2RvRWZmZWN0cyB7XG4gICAqICAgQEVmZmVjdCh7ZGlzcGF0Y2g6IGZhbHNlfSlcbiAgICogICB1cGRhdGVUb2RvOyAvLy4uLlxuICAgKiB9XG4gICAqIGBgYFxuICAgKi9cbiAgcGVzc2ltaXN0aWNVcGRhdGU8QSBleHRlbmRzIEFjdGlvbiA9IEFjdGlvbj4oXG4gICAgYWN0aW9uVHlwZTogc3RyaW5nLFxuICAgIG9wdHM6IFBlc3NpbWlzdGljVXBkYXRlT3B0czxULCBBPlxuICApOiBPYnNlcnZhYmxlPGFueT4ge1xuICAgIHJldHVybiB0aGlzLmFjdGlvbnMucGlwZShcbiAgICAgIG9mVHlwZTxBPihhY3Rpb25UeXBlKSxcbiAgICAgIHdpdGhMYXRlc3RGcm9tKHRoaXMuc3RvcmUpLFxuICAgICAgcGVzc2ltaXN0aWNVcGRhdGUob3B0cylcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEB3aGF0SXREb2VzIEhhbmRsZXMgb3B0aW1pc3RpYyB1cGRhdGVzICh1cGRhdGluZyB0aGUgY2xpZW50IGZpcnN0KS5cbiAgICpcbiAgICogYG9wdGltaXN0aWNVcGRhdGVgIGFkZHJlc3NlcyB0aGVzZSBwcm9ibGVtcy0taXQgcnVucyBhbGwgZmV0Y2hlcyBpbiBvcmRlciwgd2hpY2ggcmVtb3ZlcyByYWNlIGNvbmRpdGlvbnNcbiAgICogYW5kIGZvcmNlcyB0aGUgZGV2ZWxvcGVyIHRvIGhhbmRsZSBlcnJvcnMuXG4gICAqXG4gICAqIGBvcHRpbWlzdGljVXBkYXRlYCBpcyBkaWZmZXJlbnQgZnJvbSBgcGVzc2ltaXN0aWNVcGRhdGVgLiBJbiBjYXNlIG9mIGEgZmFpbHVyZSwgd2hlbiB1c2luZyBgb3B0aW1pc3RpY1VwZGF0ZWAsXG4gICAqIHRoZSBkZXZlbG9wZXIgYWxyZWFkeSB1cGRhdGVkIHRoZSBzdGF0ZSBsb2NhbGx5LCBzbyB0aGUgZGV2ZWxvcGVyIG11c3QgcHJvdmlkZSBhbiB1bmRvIGFjdGlvbi5cbiAgICpcbiAgICogVGhlIGVycm9yIGhhbmRsaW5nIG11c3QgYmUgZG9uZSBpbiB0aGUgY2FsbGJhY2ssIG9yIGJ5IG1lYW5zIG9mIHRoZSB1bmRvIGFjdGlvbi5cbiAgICpcbiAgICogIyMgRXhhbXBsZTpcbiAgICpcbiAgICogYGBgdHlwZXNjcmlwdFxuICAgKiBASW5qZWN0YWJsZSgpXG4gICAqIGNsYXNzIFRvZG9FZmZlY3RzIHtcbiAgICogICBARWZmZWN0KCkgdXBkYXRlVG9kbyA9IHRoaXMucy5vcHRpbWlzdGljVXBkYXRlPFVwZGF0ZVRvZG8+KCdVUERBVEVfVE9ETycsIHtcbiAgICogICAgIC8vIHByb3ZpZGVzIGFuIGFjdGlvbiBhbmQgdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIHN0b3JlXG4gICAqICAgICBydW46IChhLCBzdGF0ZSkgPT4ge1xuICAgKiAgICAgICByZXR1cm4gdGhpcy5iYWNrZW5kKHN0YXRlLnVzZXIsIGEucGF5bG9hZCk7XG4gICAqICAgICB9LFxuICAgKlxuICAgKiAgICAgdW5kb0FjdGlvbjogKGEsIGU6IGFueSkgPT4ge1xuICAgKiAgICAgICAvLyBkaXNwYXRjaCBhbiB1bmRvIGFjdGlvbiB0byB1bmRvIHRoZSBjaGFuZ2VzIGluIHRoZSBjbGllbnQgc3RhdGVcbiAgICogICAgICAgcmV0dXJuICh7XG4gICAqICAgICAgICAgdHlwZTogJ1VORE9fVVBEQVRFX1RPRE8nLFxuICAgKiAgICAgICAgIHBheWxvYWQ6IGFcbiAgICogICAgICAgfSk7XG4gICAqICAgICB9XG4gICAqICAgfSk7XG4gICAqXG4gICAqICAgY29uc3RydWN0b3IocHJpdmF0ZSBzOiBEYXRhUGVyc2lzdGVuY2U8VG9kb3NTdGF0ZT4sIHByaXZhdGUgYmFja2VuZDogQmFja2VuZCkge31cbiAgICogfVxuICAgKiBgYGBcbiAgICpcbiAgICogTm90ZSB0aGF0IGlmIHlvdSBkb24ndCByZXR1cm4gYSBuZXcgYWN0aW9uIGZyb20gdGhlIHJ1biBjYWxsYmFjaywgeW91IG11c3Qgc2V0IHRoZSBkaXNwYXRjaCBwcm9wZXJ0eVxuICAgKiBvZiB0aGUgZWZmZWN0IHRvIGZhbHNlLCBsaWtlIHRoaXM6XG4gICAqXG4gICAqIGBgYFxuICAgKiBjbGFzcyBUb2RvRWZmZWN0cyB7XG4gICAqICAgQEVmZmVjdCh7ZGlzcGF0Y2g6IGZhbHNlfSlcbiAgICogICB1cGRhdGVUb2RvOyAvLy4uLlxuICAgKiB9XG4gICAqIGBgYFxuICAgKi9cbiAgb3B0aW1pc3RpY1VwZGF0ZTxBIGV4dGVuZHMgQWN0aW9uID0gQWN0aW9uPihcbiAgICBhY3Rpb25UeXBlOiBzdHJpbmcsXG4gICAgb3B0czogT3B0aW1pc3RpY1VwZGF0ZU9wdHM8VCwgQT5cbiAgKTogT2JzZXJ2YWJsZTxhbnk+IHtcbiAgICByZXR1cm4gdGhpcy5hY3Rpb25zLnBpcGUoXG4gICAgICBvZlR5cGU8QT4oYWN0aW9uVHlwZSksXG4gICAgICB3aXRoTGF0ZXN0RnJvbSh0aGlzLnN0b3JlKSxcbiAgICAgIG9wdGltaXN0aWNVcGRhdGUob3B0cylcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEB3aGF0SXREb2VzIEhhbmRsZXMgZGF0YSBmZXRjaGluZy5cbiAgICpcbiAgICogRGF0YSBmZXRjaGluZyBpbXBsZW1lbnRlZCBuYWl2ZWx5IHN1ZmZlcnMgZnJvbSByYWNlIGNvbmRpdGlvbnMgYW5kIHBvb3IgZXJyb3IgaGFuZGxpbmcuXG4gICAqXG4gICAqIGBmZXRjaGAgYWRkcmVzc2VzIHRoZXNlIHByb2JsZW1zLS1pdCBydW5zIGFsbCBmZXRjaGVzIGluIG9yZGVyLCB3aGljaCByZW1vdmVzIHJhY2UgY29uZGl0aW9uc1xuICAgKiBhbmQgZm9yY2VzIHRoZSBkZXZlbG9wZXIgdG8gaGFuZGxlIGVycm9ycy5cbiAgICpcbiAgICogIyMgRXhhbXBsZTpcbiAgICpcbiAgICogYGBgdHlwZXNjcmlwdFxuICAgKiBASW5qZWN0YWJsZSgpXG4gICAqIGNsYXNzIFRvZG9FZmZlY3RzIHtcbiAgICogICBARWZmZWN0KCkgbG9hZFRvZG9zID0gdGhpcy5zLmZldGNoPEdldFRvZG9zPignR0VUX1RPRE9TJywge1xuICAgKiAgICAgLy8gcHJvdmlkZXMgYW4gYWN0aW9uIGFuZCB0aGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgc3RvcmVcbiAgICogICAgIHJ1bjogKGEsIHN0YXRlKSA9PiB7XG4gICAqICAgICAgIHJldHVybiB0aGlzLmJhY2tlbmQoc3RhdGUudXNlciwgYS5wYXlsb2FkKS5tYXAociA9PiAoe1xuICAgKiAgICAgICAgIHR5cGU6ICdUT0RPUycsXG4gICAqICAgICAgICAgcGF5bG9hZDogclxuICAgKiAgICAgICB9KTtcbiAgICogICAgIH0sXG4gICAqXG4gICAqICAgICBvbkVycm9yOiAoYSwgZTogYW55KSA9PiB7XG4gICAqICAgICAgIC8vIGRpc3BhdGNoIGFuIHVuZG8gYWN0aW9uIHRvIHVuZG8gdGhlIGNoYW5nZXMgaW4gdGhlIGNsaWVudCBzdGF0ZVxuICAgKiAgICAgfVxuICAgKiAgIH0pO1xuICAgKlxuICAgKiAgIGNvbnN0cnVjdG9yKHByaXZhdGUgczogRGF0YVBlcnNpc3RlbmNlPFRvZG9zU3RhdGU+LCBwcml2YXRlIGJhY2tlbmQ6IEJhY2tlbmQpIHt9XG4gICAqIH1cbiAgICogYGBgXG4gICAqXG4gICAqIFRoaXMgaXMgY29ycmVjdCwgYnV0IGJlY2F1c2UgaXQgc2V0IHRoZSBjb25jdXJyZW5jeSB0byAxLCBpdCBtYXkgbm90IGJlIHBlcmZvcm1hbnQuXG4gICAqXG4gICAqIFRvIGZpeCB0aGF0LCB5b3UgY2FuIHByb3ZpZGUgdGhlIGBpZGAgZnVuY3Rpb24sIGxpa2UgdGhpczpcbiAgICpcbiAgICogYGBgdHlwZXNjcmlwdFxuICAgKiBASW5qZWN0YWJsZSgpXG4gICAqIGNsYXNzIFRvZG9FZmZlY3RzIHtcbiAgICogICBARWZmZWN0KCkgbG9hZFRvZG8gPSB0aGlzLnMuZmV0Y2g8R2V0VG9kbz4oJ0dFVF9UT0RPJywge1xuICAgKiAgICAgaWQ6IChhLCBzdGF0ZSkgPT4ge1xuICAgKiAgICAgICByZXR1cm4gYS5wYXlsb2FkLmlkO1xuICAgKiAgICAgfVxuICAgKlxuICAgKiAgICAgLy8gcHJvdmlkZXMgYW4gYWN0aW9uIGFuZCB0aGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgc3RvcmVcbiAgICogICAgIHJ1bjogKGEsIHN0YXRlKSA9PiB7XG4gICAqICAgICAgIHJldHVybiB0aGlzLmJhY2tlbmQoc3RhdGUudXNlciwgYS5wYXlsb2FkKS5tYXAociA9PiAoe1xuICAgKiAgICAgICAgIHR5cGU6ICdUT0RPJyxcbiAgICogICAgICAgICBwYXlsb2FkOiByXG4gICAqICAgICAgIH0pO1xuICAgKiAgICAgfSxcbiAgICpcbiAgICogICAgIG9uRXJyb3I6IChhLCBlOiBhbnkpID0+IHtcbiAgICogICAgICAgLy8gZGlzcGF0Y2ggYW4gdW5kbyBhY3Rpb24gdG8gdW5kbyB0aGUgY2hhbmdlcyBpbiB0aGUgY2xpZW50IHN0YXRlXG4gICAqICAgICAgIHJldHVybiBudWxsO1xuICAgKiAgICAgfVxuICAgKiAgIH0pO1xuICAgKlxuICAgKiAgIGNvbnN0cnVjdG9yKHByaXZhdGUgczogRGF0YVBlcnNpc3RlbmNlPFRvZG9zU3RhdGU+LCBwcml2YXRlIGJhY2tlbmQ6IEJhY2tlbmQpIHt9XG4gICAqIH1cbiAgICogYGBgXG4gICAqXG4gICAqIFdpdGggdGhpcyBzZXR1cCwgdGhlIHJlcXVlc3RzIGZvciBUb2RvIDEgd2lsbCBydW4gY29uY3VycmVudGx5IHdpdGggdGhlIHJlcXVlc3RzIGZvciBUb2RvIDIuXG4gICAqXG4gICAqIEluIGFkZGl0aW9uLCBpZiBEYXRhUGVyc2lzdGVuY2Ugbm90aWNlcyB0aGF0IHRoZXJlIGFyZSBtdWx0aXBsZSByZXF1ZXN0cyBmb3IgVG9kbyAxIHNjaGVkdWxlZCxcbiAgICogaXQgd2lsbCBvbmx5IHJ1biB0aGUgbGFzdCBvbmUuXG4gICAqL1xuICBmZXRjaDxBIGV4dGVuZHMgQWN0aW9uID0gQWN0aW9uPihcbiAgICBhY3Rpb25UeXBlOiBzdHJpbmcsXG4gICAgb3B0czogRmV0Y2hPcHRzPFQsIEE+XG4gICk6IE9ic2VydmFibGU8YW55PiB7XG4gICAgcmV0dXJuIHRoaXMuYWN0aW9ucy5waXBlKFxuICAgICAgb2ZUeXBlPEE+KGFjdGlvblR5cGUpLFxuICAgICAgd2l0aExhdGVzdEZyb20odGhpcy5zdG9yZSksXG4gICAgICBmZXRjaChvcHRzKVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQHdoYXRJdERvZXMgSGFuZGxlcyBkYXRhIGZldGNoaW5nIGFzIHBhcnQgb2Ygcm91dGVyIG5hdmlnYXRpb24uXG4gICAqXG4gICAqIERhdGEgZmV0Y2hpbmcgaW1wbGVtZW50ZWQgbmFpdmVseSBzdWZmZXJzIGZyb20gcmFjZSBjb25kaXRpb25zIGFuZCBwb29yIGVycm9yIGhhbmRsaW5nLlxuICAgKlxuICAgKiBgbmF2aWdhdGlvbmAgYWRkcmVzc2VzIHRoZXNlIHByb2JsZW1zLlxuICAgKlxuICAgKiBJdCBjaGVja3MgaWYgYW4gYWN0aXZhdGVkIHJvdXRlciBzdGF0ZSBjb250YWlucyB0aGUgcGFzc2VkIGluIGNvbXBvbmVudCB0eXBlLCBhbmQsIGlmIGl0IGRvZXMsIHJ1bnMgdGhlIGBydW5gXG4gICAqIGNhbGxiYWNrLiBJdCBwcm92aWRlcyB0aGUgYWN0aXZhdGVkIHNuYXBzaG90IGFzc29jaWF0ZWQgd2l0aCB0aGUgY29tcG9uZW50IGFuZCB0aGUgY3VycmVudCBzdGF0ZS4gQW5kIGl0IG9ubHkgcnVuc1xuICAgKiB0aGUgbGFzdCByZXF1ZXN0LlxuICAgKlxuICAgKiAjIyBFeGFtcGxlOlxuICAgKlxuICAgKiBgYGB0eXBlc2NyaXB0XG4gICAqIEBJbmplY3RhYmxlKClcbiAgICogY2xhc3MgVG9kb0VmZmVjdHMge1xuICAgKiAgIEBFZmZlY3QoKSBsb2FkVG9kbyA9IHRoaXMucy5uYXZpZ2F0aW9uKFRvZG9Db21wb25lbnQsIHtcbiAgICogICAgIHJ1bjogKGEsIHN0YXRlKSA9PiB7XG4gICAqICAgICAgIHJldHVybiB0aGlzLmJhY2tlbmQuZmV0Y2hUb2RvKGEucGFyYW1zWydpZCddKS5tYXAodG9kbyA9PiAoe1xuICAgKiAgICAgICAgIHR5cGU6ICdUT0RPX0xPQURFRCcsXG4gICAqICAgICAgICAgcGF5bG9hZDogdG9kb1xuICAgKiAgICAgICB9KSk7XG4gICAqICAgICB9LFxuICAgKiAgICAgb25FcnJvcjogKGEsIGU6IGFueSkgPT4ge1xuICAgKiAgICAgICAvLyB3ZSBjYW4gbG9nIGFuZCBlcnJvciBoZXJlIGFuZCByZXR1cm4gbnVsbFxuICAgKiAgICAgICAvLyB3ZSBjYW4gYWxzbyBuYXZpZ2F0ZSBiYWNrXG4gICAqICAgICAgIHJldHVybiBudWxsO1xuICAgKiAgICAgfVxuICAgKiAgIH0pO1xuICAgKiAgIGNvbnN0cnVjdG9yKHByaXZhdGUgczogRGF0YVBlcnNpc3RlbmNlPFRvZG9zU3RhdGU+LCBwcml2YXRlIGJhY2tlbmQ6IEJhY2tlbmQpIHt9XG4gICAqIH1cbiAgICogYGBgXG4gICAqL1xuICBuYXZpZ2F0aW9uKFxuICAgIGNvbXBvbmVudDogVHlwZTxhbnk+LFxuICAgIG9wdHM6IEhhbmRsZU5hdmlnYXRpb25PcHRzPFQ+XG4gICk6IE9ic2VydmFibGU8YW55PiB7XG4gICAgcmV0dXJuIHRoaXMuYWN0aW9ucy5waXBlKFxuICAgICAgd2l0aExhdGVzdEZyb20odGhpcy5zdG9yZSksXG4gICAgICBuYXZpZ2F0aW9uKGNvbXBvbmVudCwgb3B0cylcbiAgICApO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmRTbmFwc2hvdChcbiAgY29tcG9uZW50OiBUeXBlPGFueT4sXG4gIHM6IEFjdGl2YXRlZFJvdXRlU25hcHNob3Rcbik6IEFjdGl2YXRlZFJvdXRlU25hcHNob3Qge1xuICBpZiAocy5yb3V0ZUNvbmZpZyAmJiBzLnJvdXRlQ29uZmlnLmNvbXBvbmVudCA9PT0gY29tcG9uZW50KSB7XG4gICAgcmV0dXJuIHM7XG4gIH1cbiAgZm9yIChjb25zdCBjIG9mIHMuY2hpbGRyZW4pIHtcbiAgICBjb25zdCBzcyA9IGZpbmRTbmFwc2hvdChjb21wb25lbnQsIGMpO1xuICAgIGlmIChzcykge1xuICAgICAgcmV0dXJuIHNzO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gd3JhcEludG9PYnNlcnZhYmxlPE8+KG9iajogT2JzZXJ2YWJsZTxPPiB8IE8gfCB2b2lkKTogT2JzZXJ2YWJsZTxPPiB7XG4gIGlmICghIW9iaiAmJiBvYmogaW5zdGFuY2VvZiBPYnNlcnZhYmxlKSB7XG4gICAgcmV0dXJuIG9iajtcbiAgfSBlbHNlIGlmICghb2JqKSB7XG4gICAgcmV0dXJuIG9mKCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG9mKG9iaiBhcyBPKTtcbiAgfVxufVxuIl19